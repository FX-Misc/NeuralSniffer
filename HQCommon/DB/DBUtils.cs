//#define MeasureToUtcToLocal
using System;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Linq;
using System.Data.SqlClient;
using System.Threading;
using System.Diagnostics;
using System.Text.RegularExpressions;

namespace HQCommon
{
    public enum DBType
    {
        Local  = 0,
        Remote = 1
    }

    public enum FindOrCreatePortfolioMode
    {
        Find,
        FindAndDelete,
        CreateIfMissing,
        ForceRecreate
    }

    public static partial class DBUtils
    {
        public const char FolderPathSeparator = '\\';
        //public static readonly string g_FolderPathSeparatorStr = FolderPathSeparator.ToString();

        /// <summary> This variable is also initialized from HQDesktop </summary>
        public static System.Globalization.CultureInfo g_localCultureInfo
            = Thread.CurrentThread.CurrentCulture;      // default value when HQDesktop does not run

        #region Date-related
        /// <summary>
        /// Returns a date-only string (without quotes) in a format which is suitable 
        /// in SQL commands.
        /// IMPORTANT: the current format of the string ("05/24/2008") should be changeable
        /// when the SQL server changes, so don't use this method for other purposes
        /// than SQL communication!
        /// </summary>
        // TODO: a szerver megerti a YYYYMMDD formatumot is! Ez annyibol jobb h. rovidebb
        // A help-ben igy talalod meg: 'Unseparated String Format'.  {0:yyyyMMdd}
        // http://msdn.microsoft.com/en-us/library/ms180878.aspx#UnseparatedStringFormat
        public static string Date2Str(DateTime p_date)
        {
            return p_date.ToString("d", Utils.InvCult);
        }
        /// <summary> "10" </summary>
        public static string DateStrLength
        {
            get
            {
                if (g_dateStrLength == null)                // 2010-05-23
                    g_dateStrLength = Date2Str(new DateTime(0x08cc9832ea5ac000L)).Length.ToString(Utils.InvCult);
                return g_dateStrLength;
            }
        }
        static internal string g_dateStrLength;

        /// <summary> Returns an UTC date+time string in a format suitable in SQL commands.
        /// IMPORTANT: the current format of the string ("2008-10-05T13:00:01Z") should be
        /// changeable when the SQL server changes, so don't use this method for other 
        /// purposes than SQL communication!
        /// </summary>
        // See SQL Server 2008 Books Online > String Literal Date and Time Formats
        // http://msdn.microsoft.com/en-us/library/ms180878.aspx#StringLiteralDateandTimeFormats
        // '2008-10-05T13:00:01Z' is ISO-8601 standard, independent from the current DATEFORMAT 
        //  setting and language. Note: the seconds part can not be omitted.
        public static string UtcDateTime2Str(DateTime p_dateTimeUtc)
        {
            return p_dateTimeUtc.ToString("yyyy'-'MM'-'dd'T'HH':'mm':'ss'Z'", Utils.InvCult);
        }

        /// <summary> Returns a date+time string in a format suitable in SQL commands.
        /// IMPORTANT: the current format of the string ("2008-10-05T13:00:01" or "2008-10-05")
        /// should be changeable when the SQL server changes, so don't use this method
        /// for other purposes than SQL communication! </summary>
        public static string DateTime2Str(DateTime p_dateTimeUtc)
        {
            return p_dateTimeUtc.ToString(p_dateTimeUtc.TimeOfDay.Ticks < TimeSpan.TicksPerSecond ? "yyyy'-'MM'-'dd"
                : "yyyy'-'MM'-'dd'T'HH':'mm':'ss", Utils.InvCult);
        }

        /// <summary> Interprets a date (or date+time) string returned by the SQL Server. </summary>
        public static DateTime Str2DateTimeUtc(string p_date)
        {
            return DateTime.Parse(p_date, Utils.InvCult,
                System.Globalization.DateTimeStyles.AdjustToUniversal);
        }

        public static DateTime? GetTimeOfLastValidStockQuoteRecordOnServer(DBManager p_dbManager,
            int p_timeoutSec = -1)
        {
            string s = Utils.DBNullCast<string>(p_dbManager.ExecuteSqlCommand(DBType.Remote,
                "SELECT Value FROM MiscProperties WHERE Name = 'StockQuoteLastTimeUtc'",
                CommandType.Text, null, SqlCommandReturn.SimpleScalar, p_timeoutSec));
                                                            // Utils.Str2↓↓() is used because this string is generated by
            try {
                return String.IsNullOrEmpty(s) ? (DateTime?)null : Utils.Str2DateTimeUtc(s);    // the crawler, not the SqlServer
            } catch {
                return null;    // parse error
            }
        }

        [Obsolete]
        public static DateTime GetNextUsaMarketOpenDay(this DateTime p_exclusiveUtc, object p_dbManager)
        {
            // HACK: the following handles time parameter as ET (instead of UTC)!
            // should be corrected when the algorithms pass UTC to it correctly
            return AddMarketTimeLocInternal(p_exclusiveUtc.Date, 0, Utils.g_1day,
                CountryID.UnitedStates, p_dbManager);
        }
        /// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        public static DateTime GetNextMarketOpenDay(this DateTime p_timeUtc,
            StockExchangeID p_xchg, object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            DateTime timeLoc = tzRec.ToLocal(p_timeUtc);
            return tzRec.ToUtc(AddMarketTimeLocInternal(timeLoc.Date, 0, Utils.g_1day,
                tzRec.CountryID, p_dbManager));
        }

        [Obsolete]
        public static DateTime GetNextUsaMarketOpenDayInclusive(this DateTime p_timeUtc, object p_dbManager)
        {
            // HACK: the following handles time parameter as ET (instead of UTC)!
            // should be corrected when the algorithms pass UTC to it correctly
            return AddMarketTimeLocInternal(p_timeUtc.Date, 0, TimeSpan.Zero,
                CountryID.UnitedStates, p_dbManager);
        }
        /// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        public static DateTime GetNextMarketOpenDayInclusive(this DateTime p_timeUtc,
            StockExchangeID p_xchg, object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            DateTime timeLoc = tzRec.ToLocal(p_timeUtc);
            return tzRec.ToUtc(AddMarketTimeLocInternal(timeLoc.Date, 0, TimeSpan.Zero,
                tzRec.CountryID, p_dbManager));
        }

        [Obsolete]
        public static DateTime GetPreviousUsaMarketOpenDay(this DateTime p_exclusiveUtc, object p_dbManager)
        {
            // HACK: the following handles time parameter as ET (instead of UTC)!
            // should be corrected when the algorithms pass UTC to it correctly
            return AddMarketTimeLocInternal(p_exclusiveUtc.Date, 0, -Utils.g_1day,
                CountryID.UnitedStates, p_dbManager);
        }
        ///// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        //[Obsolete("Avoid using this function or delete this obsolete attribute")]
        //public static DateTime GetPreviousMarketOpenDay(this DateTime p_timeUtc, 
        //    StockExchangeID p_xchg, DBManager p_dbManager)
        //{
        //    return GetPreviousMarketOpenDay(p_timeUtc,
        //        FindTimeZoneRec(p_xchg, p_dbManager), p_dbManager);
        //}
        /// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        public static DateTime GetPreviousMarketOpenDay(this DateTime p_timeUtc,
            StockExchangeID p_xchg, object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            DateTime timeLoc = tzRec.ToLocal(p_timeUtc);
            return tzRec.ToUtc(AddMarketTimeLocInternal(timeLoc.Date, 0, -Utils.g_1day,
                tzRec.CountryID, p_dbManager));
        }

        [Obsolete]
        public static DateTime GetPreviousUsaMarketOpenDayInclusive(this DateTime p_timeUtc,
            object p_dbManager)
        {
            // HACK: the following handles time parameter as ET (instead of UTC)!
            // should be corrected when the algorithms pass UTC to it correctly
            return AddMarketTimeLocInternal(p_timeUtc.Date, 1, TimeSpan.FromTicks(-1),
                FindTimeZoneRec(StockExchangeID.NASDAQ, p_dbManager).CountryID, p_dbManager).Date;
        }
        ///// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        //[Obsolete("Avoid using this function or delete this obsolete attribute")]
        //public static DateTime GetPreviousMarketOpenDayInclusive(this DateTime p_timeUtc, 
        //    StockExchangeID p_xchg, DBManager p_dbManager)
        //{
        //    return GetPreviousMarketOpenDayInclusive(p_timeUtc,
        //        FindTimeZoneRec(p_xchg, p_dbManager), p_dbManager);
        //}
        /// <summary> Postcondition: result.TimeOfDay == local 00:00 converted to UTC </summary>
        public static DateTime GetPreviousMarketOpenDayInclusive(this DateTime p_timeUtc,
            StockExchangeID p_xchg, object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            DateTime timeLoc = tzRec.ToLocal(p_timeUtc);
            return tzRec.ToUtc(AddMarketTimeLocInternal(timeLoc.Date, 1, TimeSpan.FromTicks(-1),
                tzRec.CountryID, p_dbManager).Date);
        }


        public static DateTime AddMarketDaysUtc(this DateTime p_timeUtc, double p_nDays,
            StockExchangeID p_xchg, object p_dbManager)
        {
            return AddMarketTimeUtc(p_timeUtc, TimeSpan.FromDays(p_nDays), p_xchg, p_dbManager);
        }

        /// <summary> Accepts and returns UTC time (converts it to local time
        /// and back to UTC internally). p_dbManager may be null after the first time. </summary>
        public static DateTime AddMarketTimeUtc(this DateTime p_timeUtc, TimeSpan p_timeSpan,
            StockExchangeID p_xchg, object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            return tzRec.ToUtc(AddMarketTimeLoc(tzRec.ToLocal(p_timeUtc), p_timeSpan,
                tzRec.CountryID, p_dbManager));
        }
        /// <summary> Accepts and returns local time. Examples:<para>
        /// 23:55 Friday + 6min        == 00:01 Monday;</para><para>
        /// 00:01 Monday - 6min        == 23:55 Friday;</para><para>
        /// 14:00 Sunday + [0min..10h] == 00:00 Monday;</para><para>
        /// 14:00 Sunday + 10h 1min    == 00:01 Monday;</para><para>
        /// 14:00 Sunday - (0min..14h] == 23:59 Friday;</para><para>
        /// 14:00 Sunday - 14h 2min    == 23:58 Friday</para>
        /// </summary>
        public static DateTime AddMarketTimeLoc(this DateTime p_timeLoc, TimeSpan p_timeSpan,
            CountryID p_countryID, object p_dbManager)
        {
            DateTime dateLoc = p_timeLoc.Date;
            return AddMarketTimeLocInternal(dateLoc, (p_timeLoc - dateLoc).Ticks, p_timeSpan,
                p_countryID, p_dbManager);
        }
        public static DateTime AddMarketTimeLoc2(this DateOnly p_dateLoc, TimeSpan p_timeSpan,
            CountryID p_countryID, object p_dbManager)
        {
            return AddMarketTimeLocInternal(p_dateLoc, 0, p_timeSpan, p_countryID, p_dbManager);
        }
        /// <summary> Precondition: p_date.TimeOfDay == 0. Returns DateTime.Kind := Unspecified </summary>
        static DateTime AddMarketTimeLocInternal(DateTime p_date, long p_timeOfDay,
            TimeSpan p_timeSpan, CountryID p_countryID, object p_dbManager)
        {
            long t = p_timeSpan.Ticks, sign = t >> 63;      // sign: 0=addition, -1=subtraction
            long d = (TimeSpan.TicksPerDay ^ sign) - sign;  // +/- TimeSpan.TicksPerDay
            t += p_timeOfDay - d;                   // t := addition ? p_timeSpan - timeToTomorrow 
                                                    //               : p_timeSpan + timeOfDay + TicksPerDay
            if ((t ^ sign) >= (d & sign))           // in case of subtraction, this means  ~t >= d  <=>  -t-1 >= d  <=>  -t > d  <=>
            { }                                     // <=> t < -d  <=>  p_timeSpan + timeOfDay < 0
            else if (IsMarketOpenDayLoc(p_date, p_countryID, p_dbManager))
                return p_date.AddTicks(t + d);      // affects time but not date
            else
                t = (d & sign) ^ sign;              // == addition ? 0 : TicksPerDay-1
            while (true)
            {
                do { p_date = p_date.AddTicks(d); }
                while (!IsMarketOpenDayLoc(p_date, p_countryID, p_dbManager));
                if (unchecked((ulong)t < (ulong)TimeSpan.TicksPerDay))  // t is in [0,TicksPerDay)
                    return p_date.AddTicks(t);
                t -= d;
            }
        }
        [Obsolete]
        public static bool IsUsaMarketOpenDay(DateTime p_timeUtc, object p_dbManager)
        {
            // HACK: the following handles time parameter as ET (instead of UTC)!
            // should be corrected when the algorithms pass UTC to it correctly
            return IsMarketOpenDayLoc(p_timeUtc.Date, CountryID.UnitedStates, p_dbManager);
        }
        public static bool IsMarketOpenDay(this DateTime p_timeUtc, StockExchangeID p_xchg,
            object p_dbManager)
        {
            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            return IsMarketOpenDayLoc(tzRec.ToLocal(p_timeUtc).Date, tzRec.CountryID,
                p_dbManager);
        }
        /// <summary> Precondition: p_dateLocal.TimeOfDay == 0 </summary>
        // See also http://www.isthemarketopen.com/,
        // http://www.chronos-st.org/NYSE_Observed_Holidays-1885-Present.html
        public static bool IsMarketOpenDayLoc(DateTime p_dateLocal, CountryID p_countryID,
            object p_dbManager)
        {
            DayOfWeek day = p_dateLocal.DayOfWeek;
            if (day == DayOfWeek.Sunday || day == DayOfWeek.Saturday)
                return false;
            if (g_marketHolidays.Length != 0)
                g_IsMarketOpenDayLoc_chgntf.UpdateNowIfMissed(p_dbManager);
            else
                lock ((object)g_marketHolidays)
                    if (g_marketHolidays.Length == 0)
                    {
                        DBManager dbManager = DBManager.FromObject(p_dbManager, p_throwOnNull: false);
                        IEnumerable<int> ascending;
                        if (dbManager == null || !dbManager.IsEnabled)
                        {
                            Utils.Logger.Warning("Warning: {0} falls back to generated MarketHolidays", Utils.GetCurrentMethodName(null, true));
                            int[] tmp = Utils.CrossProduct(new[] { CountryID.UnitedStates, CountryID.UnitedKingdom, CountryID.Germany },
                                Enumerable.Range(2000, DateTime.UtcNow.Year - 1999))
                            .SelectMany(cy => CalculateDefaultMarketHolidays(cy.Value, cy.Key).Select(d => Encode(d, cy.Key))).ToArrayFast();
                            Array.Sort(tmp);
                            ascending = tmp;
                        }
                        else if (dbManager.MemTables.IsLoaded(_ => _.MarketHoliday))
                        {   // use MemTables
                            ascending = dbManager.MemTables.MarketHoliday.Values
                                .Select(row => Encode(row.Date, row.CountryID)).Sort();
                            // delete MemTables.MarketHoliday from memory because likely nobody will use it any longer
                            ChangeNotification.OnMemTableChange(_ => _.MarketHoliday, p_reloadNow: false);
                        }
                        else
                        {   // use query
                            ascending = dbManager.ExecuteQuery("SELECT CountryID, Date FROM MarketHoliday ORDER BY CountryID, Date",
                                g_readingTimeoutSec).Rows.Cast<DataRow>().Select(row =>
                                    Encode((DateTime)row[1], (CountryID)Convert.ToByte(row[0])));
                        }
                        g_marketHolidays = ascending.DefaultIfEmpty(Encode(new DateTime(1901, 01, 01), CountryID.UnitedStates)).ToArray();
                        Utils.DebugAssert(0 < g_marketHolidays.Length);

                        g_IsMarketOpenDayLoc_chgntf.AddHandler(dbManager, (dbM, _) => {
                            int[] g = g_marketHolidays;
                            if (0 < g.Length && Interlocked.CompareExchange(ref g_marketHolidays, new int[0], g) == g)
                                IsMarketOpenDayLoc(new DateTime(2010, 1, 1) /* Friday */, CountryID.UnitedStates, dbM);
                        }).SetDependency<MemTables.MarketHoliday>(ChangeNotification.Flags.AllTableEvents
                                                                | ChangeNotification.Flags.OfflineToOnlineTransition);
                    }
                   // (p_dateLocal.Ticks < DateOnly.MinTicks || DateOnly.MaxTicks < p_dateLocal.Ticks) -- faster:
            return unchecked((ulong)(DateOnly.MaxTicks - p_dateLocal.Ticks) > (ulong)(DateOnly.MaxTicks - DateOnly.MinTicks))
                || 0 > Array.BinarySearch(g_marketHolidays, Encode(p_dateLocal, p_countryID));
        }
        static int[] g_marketHolidays = new int[0];
        static StaticChangeHandlerWithWeakRef<DBManager> g_IsMarketOpenDayLoc_chgntf;

        static int Encode(DateOnly p_date, CountryID p_country)
        {
            return (((byte)p_country) << 16) + p_date.ToBinary();
        }

        // http://en.wikipedia.org/wiki/List_of_holidays_by_country
        static IEnumerable<DateTime> CalculateDefaultMarketHolidays(int p_year, CountryID p_country)
        {
            sbyte[] table = null; const sbyte Easter = 1, Round2Wk = 2, NthMon = 3, OnlyIn = 4;
            switch (p_country) {
                case CountryID.UnitedStates: table = new sbyte[] {
                       1, 1, Round2Wk, 4  // New year's day. If Sunday, then 2 Jan.
                    ,  1, 1, NthMon,   3  // Martin Luther King's day: third Monday of Jan
                    ,  2, 1, NthMon,   3  // Presidents' Day: third Monday of Feb
                    ,  3, 1, Easter,  -2  // Good Friday (March or April)
                    ,  5,25, NthMon,   1  // Memorial Day: last Monday in May
                    ,  7, 4, Round2Wk, 5  // Independence Day: 4 July, rounded to weekday
                    ,  9, 1, NthMon,   1  // Labor Day: first Monday of Sep
                    , 11, 1, NthMon,   4|(3<<3)// Thanksgiving Day: 4th Thursday in Nov  (3==Thursday)
                    , 12,25, Round2Wk, 5  // Christmas Day
                    ,  9,11, OnlyIn,   1, 9,12,OnlyIn,1, 9,13,OnlyIn,1, 9,14,OnlyIn,1 // 2001-09-11..14
                    ,  6,11, OnlyIn,   4  // Funeral of Ronald Reagan (2004)
                    ,  1, 2, OnlyIn,   7  // Mourning for former President Gerald R. Ford (2007)
                    , 10,29, OnlyIn,  12, 10,30,OnlyIn,12   // Hurricane Sandy (2012)
                }; break;
                case CountryID.UnitedKingdom: table = new sbyte[] {       // https://www.gov.uk/bank-holidays
                       1, 1, Round2Wk, 6  // New year's day. Weekend->Monday
                    ,  3, 1, Easter,  -2  // Good Friday
                    ,  3, 1, Easter,   1  // Easter Monday
                    ,  5, 1, NthMon,   1  // May Day: 1st Monday
                    ,  5,25, NthMon,   1  // Spring Bank Holiday: last Monday in May
                    ,  8,25, NthMon,   1  // Summer Bank Holiday: last Monday in August
                    , 12,25, Round2Wk, 2|4// Christmas Day
                    , 12,26, Round2Wk, 8  // Boxing Day
                }; break;
                case CountryID.Germany: table = new sbyte[] { // goo.gl/97Np9G + http://www.boerse-frankfurt.de/en/events/international_trading_calendar
                       1, 1, 0,        0  // New year's day
                    ,  3, 1, Easter,  -2  // Good Friday
                    ,  3, 1, Easter,   1  // Easter Monday
                    ,  5, 1, 0,        0  // Labour Day
                    , 10, 3, 0,        0  // Day of German Unity
                    , 12,24, 0,        0  // Christmas Eve
                    , 12,25, 0,        0  // Christmas Day
                    , 12,26, 0,        0  // Boxing Day
                    , 12,31, 0,        0  // New Year's Eve
                }; break;
            }
            int n = (table == null ? 0 : table.Length);
            var result = new List<DateTime>(n >> 2);
            for (int i = 0; i < n; i += 4)
            {
                DateTime d = new DateTime(p_year, table[i], table[i + 1]);
                int func = table[i + 2], arg = table[i + 3];
                if      (func == Easter  ) d = Utils.GetEasterSundayInYear(p_year).AddDays(arg);
                else if (func == Round2Wk) d = Utils.RoundToWeekday(d, arg);
                else if (func == NthMon  ) d = Utils.GetNthXDayOfAMonth(arg & 7, (DayOfWeek)((int)DayOfWeek.Monday + (arg >> 3)), d);
                else if (func == OnlyIn  && 2000 + arg != p_year) continue;
                if (!d.IsWeekend()) result.Add(d);
            }
            return result;
        }

        /// <summary> Computes the time difference (delta) between p_timeUtc0 (t0)
        /// and p_timeUtc1 (t1), so that delta == GetMarketOpenDaysDiff(t0,t1,...)
        /// when t1 == t0.AddMarketTimeUtc(delta,...). If t1 is weekend or bank
        /// holiday, no such 'delta' exists. In this case the function returns a
        /// smaller value: the largest 'delta' for which t0.AddMarketTimeUtc(delta,...)
        /// &lt;= t1. Examples:
        /// p_timeUtc0=23:55 Friday, p_timeUtc1=00:01 Monday:  6 min
        /// p_timeUtc0=00:01 Monday, p_timeUtc1=23:55 Friday: -6 min
        /// p_timeUtc0=14:00 Sunday, p_timeUtc1=00:00 Monday: 10h
        /// p_timeUtc0=14:00 Sunday, p_timeUtc1=00:01 Monday: 10h 1min
        /// p_timeUtc0=14:00 Sunday, p_timeUtc1=23:59 Friday: -1 min
        /// p_timeUtc0=14:00 Sunday, p_timeUtc1=23:58 Friday: -2 min
        /// </summary>
        public static TimeSpan GetMarketOpenDaysDiff(DateTime p_timeUtc0, DateTime p_timeUtc1,
            StockExchangeID p_xchg, object p_dbManager)
        {
            if (p_timeUtc0 == p_timeUtc1)
                return TimeSpan.Zero;
            if (p_timeUtc0 > p_timeUtc1)
                return -GetMarketOpenDaysDiff(p_timeUtc1, p_timeUtc0, p_xchg, p_dbManager);

            StockExchangeTimeZoneData tzRec = FindTimeZoneRec(p_xchg, p_dbManager);
            DateTime loc0 = tzRec.ToLocal(p_timeUtc0), loc1 = tzRec.ToLocal(p_timeUtc1);
            loc1 = loc1.AddTicks(1).AddMarketTimeLoc(TimeSpan.FromTicks(-1), tzRec.CountryID, p_dbManager);
            if (loc0 > loc1)
                return TimeSpan.Zero;
            var helper = new GetMarketOpenDaysDiffHelper {
                m_loc0 = loc0,
                m_countryId = tzRec.CountryID,
                m_dbManager = p_dbManager
            };
            TimeSpan timeOfDay1 = loc1.TimeOfDay;
            loc1 -= timeOfDay1;
            helper.m_count = (int)((loc1 - helper.m_loc0).Ticks / TimeSpan.TicksPerDay) + 1;
            int i = (helper.m_count > 0) ? Utils.BinarySearch(helper, loc1)
                                         : helper.m_count >> 31;
            Utils.StrongAssert(i >= 0);
            TimeSpan result = timeOfDay1 - loc0.TimeOfDay + TimeSpan.FromTicks(i * TimeSpan.TicksPerDay);
            Utils.DebugAssert(p_timeUtc0.AddMarketTimeUtc(result, tzRec.StockExchangeID, p_dbManager) == p_timeUtc1
                || p_timeUtc1 < p_timeUtc0.AddMarketTimeUtc(result + new TimeSpan(1), tzRec.StockExchangeID,
                                                            p_dbManager));
            return result;
        }
        class GetMarketOpenDaysDiffHelper : AbstractList<DateTime>
        {
            internal DateOnly m_loc0;
            internal CountryID m_countryId;
            internal object m_dbManager;
            internal int m_count;
            public override int Count { get { return m_count; } }
            public override DateTime this[int index]
            {
                get
                {
                    return m_loc0.AddMarketTimeLoc2(TimeSpan.FromTicks(index * TimeSpan.TicksPerDay),
                        m_countryId, m_dbManager);
                }
                set { throw new InvalidOperationException(); }
            }
        }

        /// <summary> Returns local times. p_dbManager may be null if p_assetOrTzRec is a tzRec
        /// (or InitTimeZoneData() has been called). Otherwise p_assetOrTzRec must be an IAssetID,
        /// and the sequence will stop at the beginning of the lifetime of the given asset
        /// (or at DateOnly.MinValue if the lifetime is LivingAssets.Always) </summary>
        public static IEnumerable<DateOnly> GenerateMarketOpenDaysDescending(DateTime p_endUtc,
            object p_assetOrTzRec, DBManager p_dbManager)
        {
            foreach (DateTime loc in GenerateMarketOpenTimesDescending(p_endUtc,
                (TimeSpan.TicksPerDay << 11) | 1, p_assetOrTzRec, p_dbManager))
                yield return loc;
        }

        /// <summary> p_stepAndFlags = (step巜11 | timeFlags), where 'step' is ticks
        /// (max.10 years) if >120, otherwise number of months; 'timeFlags' is combination
        /// of bits: 1 = p_time is Utc, 2 = returned times must be Utc.
        /// If p_assetOrTzRec is a tzRec (or InitTimeZoneData() has been called),
        /// p_dbManager may be null. If p_assetOrTzRec is not a tzRec, it must be an IAssetID,
        /// and the sequence will stop at the beginning of the lifetime of the given asset
        /// (or at DateOnly.MinValue if the lifetime is LivingAssets.Always) </summary>
        public static IEnumerable<DateTime> GenerateMarketOpenTimesDescending(DateTime p_time, long p_stepAndFlags,
            object p_assetOrTzRec, object p_dbManager)
        {
            const uint UTCin = 1, UTCout = 2;
            KeyValuePair<DateTime, DateTime> fromTo = LivingAssets.Always;
            var asset = p_assetOrTzRec as IAssetID;
            if (asset != null && LivingAssets.Equals(fromTo = LivingAssets.GetLifeTime(asset), LivingAssets.Never))
                yield break;
            var tzRec = (p_assetOrTzRec as DBUtils.StockExchangeTimeZoneData) ??
                DBUtils.FindTimeZoneRec(asset.GetStockExchange(p_dbManager), p_dbManager);
            DateTime loc;                                   // loc:=Min(LifeTime.End, p_time).ToLocal(). p_time may be local. Attempt to avoid time-zone conversion.
            long step = (fromTo.Value - p_time).Ticks;      // if p_time is local and LifeTime.End is far from it, time-zone conversion can be omitted
            if ((p_stepAndFlags & UTCin) != 0)              // cannot avoid time-zone conversion: 'p_time' is UTC
                loc = tzRec.ToLocal(Utils.Min(p_time, fromTo.Value));
            else if (13 * TimeSpan.TicksPerHour <= step)
                loc = p_time;                               // LifeTime.End is far, we don't have to care about it
            else
                loc = Utils.Min(p_time, tzRec.ToLocal(fromTo.Value));
            step = (p_stepAndFlags < 0) ? (p_stepAndFlags >> 11) : -(p_stepAndFlags >> 11);
            bool isUtcOut = ((p_stepAndFlags & UTCout) != 0), isWholeDay = (step % TimeSpan.TicksPerDay == 0);

            DateTime stop = (fromTo.Key == LivingAssets.Always.Key) ? new DateTime(DateOnly.MinTicks)
                                                                    : tzRec.ToLocal(fromTo.Key);
            for (long timeOfDay = loc.TimeOfDay.Ticks; stop <= loc; )
            {
                // TimeOfDay-preserving GetPreviousMarketOpenDayInclusive():
                loc = AddMarketTimeLocInternal(loc.AddTicks(-timeOfDay), 1, TimeSpan.FromTicks(-1),
                        tzRec.CountryID, p_dbManager).Date.AddTicks(timeOfDay);

                yield return isUtcOut ? tzRec.ToUtc(loc) : loc;
                loc = (step < -120) ? loc.AddTicks(step) : loc.AddMonths((int)step);
                if (!isWholeDay)
                    timeOfDay = loc.TimeOfDay.Ticks;
            }
        }

/*
        /// <summary> p_query() is a general query that returns 0 or 1 historical record for every input DateTime
        /// (which comes in descending order) potentially the same record multiple times. This method eliminates
        /// the duplicate records and calls p_query() again and again until p_count records are produced or
        /// p_query() returns null/empty or there's no more historical times about p_assetOrTzRec (the beginning
        /// of the asset's life time is reached). Returns T items in MRF order (most recent first, descending).
        /// <para> p_stepAndFlags = (step巜11 | timeFlags), where 'step' is ticks (max.10 years) if >120, otherwise
        /// number of months; 'timeFlags' is combination of bits: 1 = p_endTime is UTC, 2 = input of p_query() is UTC
        /// </para> p_equality == null means the EqualityComparer&lt;T&gt;.Default </summary>
        public static IEnumerable<T> ProduceUniqueHistoricalRecords<T>(DateTime p_endTime, int p_count,
            long p_stepAndFlags, object p_assetOrTzRec, object p_dbManager, IEqualityComparer<T> p_equality,
            Func<IEnumerable<DateTime>, IEnumerable<T>> p_query)
        {
            if (p_count <= 0)
                yield break;
            using (var it = GenerateMarketOpenTimesDescending(p_endTime, p_stepAndFlags,
                p_assetOrTzRec, p_dbManager).GetEnumerator())
            {
                bool[] hasMore = { it.MoveNext() };
                for (int before = -1, nDone = 0; hasMore[0] && before < nDone && nDone < p_count; )
                {
                    IEnumerable<T> part = p_query(it.Take((uint)(p_count - nDone), hasMore));
                    before = nDone;
                    foreach (T t in Utils.MakeUniqueEqCmp(part, p_equality))
                    {
                        yield return t;
                        if (p_count <= ++nDone)
                            break;
                    }
                }
            }
        }

        public static List<T> ProduceArrayOfUniqueHistoricalRecords<T>(DateTime p_endTime, int p_count,
            long p_stepAndFlags, object p_assetOrTzRec, object p_dbManager, IEqualityComparer<T> p_equality,
            Func<IEnumerable<DateTime>, IEnumerable<T>> p_query)
        {
            var result = new List<T>(p_count);
            result.AddRange(ProduceUniqueHistoricalRecords(p_endTime, p_count, p_stepAndFlags, p_assetOrTzRec,
                p_dbManager, p_equality, p_query));
            return result;
        }
*/
        public static DateTime ToUtc(this DateTime p_localTime, StockExchangeID p_stockExchange,
            object p_dbManager)
        {
            return FindTimeZoneRec(p_stockExchange, p_dbManager).ToUtc(p_localTime);
        }
        /// <summary> Precondition: InitTimeZoneData() has been called, 
        /// and p_localTime.Kind != Utc </summary>
        public static DateTime ToUtc(this DateTime p_localTime, StockExchangeID p_stockExchange)
        {
            return FindTimeZoneRec(p_stockExchange, null).ToUtc(p_localTime);
        }
        public static DateTime ToUtc(this DateTime p_localTime, IAssetID p_asset,
            object p_dbManager)
        {
            return p_localTime.ToUtc(GetStockExchange(p_asset, p_dbManager), p_dbManager);
        }
        public static DateTime ToUtc(this DateTime p_localTime, AssetIdInt32Bits p_asset, object p_dbManager)
        {
            return p_localTime.ToUtc(GetStockExchange(p_asset.AssetTypeID, p_asset.SubTableID, p_dbManager), p_dbManager);
        }
        public static DateTime ToUtc(this DateTime p_localTime, TimeZoneID p_timeZone)
        {
            return StockExchangeTimeZoneData.ToUtc(p_localTime, GetTimeZoneInfo(p_timeZone));
        }
        public static DateTime ToLocal(this DateTime p_timeUtc, StockExchangeID p_stockExchange,
            object p_dbManager)
        {
            return FindTimeZoneRec(p_stockExchange, p_dbManager).ToLocal(p_timeUtc);
        }
        /// <summary> Precondition: InitTimeZoneData() has been called </summary>
        public static DateTime ToLocal(this DateTime p_timeUtc, StockExchangeID p_stockExchange)
        {
            return FindTimeZoneRec(p_stockExchange, null).ToLocal(p_timeUtc);
        }
        public static DateTime ToLocal(this DateTime p_timeUtc, IAssetID p_asset,
            object p_dbManager)
        {
            return p_timeUtc.ToLocal(GetStockExchange(p_asset, p_dbManager), p_dbManager);
        }
        public static DateTime ToLocal(this DateTime p_timeUtc, AssetIdInt32Bits p_asset, object p_dbManager)
        {
            return p_timeUtc.ToLocal(GetStockExchange(p_asset.AssetTypeID, p_asset.SubTableID, p_dbManager), p_dbManager);
        }
        public static DateTime ToLocal(this DateTime p_timeUtc, TimeZoneID p_timeZone)
        {
            return StockExchangeTimeZoneData.ToLocal(p_timeUtc, GetTimeZoneInfo(p_timeZone));
        }

        /// <param name="p_dbManager">Any object supported by DBManager.FromObject()</param>
        public static StockExchangeTimeZoneData FindTimeZoneRec(StockExchangeID p_xchg, object p_dbManager = null)
        {
            InitTimeZoneData(p_dbManager, false);
            if (unchecked((uint)-(int)p_xchg <= (uint)-g_timeZoneInfo.Length))    // if not (0 < p_xchg < g_timeZoneInfo.Length)
                p_xchg = StockExchangeID.NASDAQ;        // Default stock exchange
            return g_timeZoneInfo[(int)p_xchg];
        }
        public static StockExchangeTimeZoneData FindTimeZoneRec(CountryID p_country, object p_dbManager = null)
        {
            if (p_country == CountryID.Unknown)
                return null;
            InitTimeZoneData(p_dbManager, false);
            foreach (StockExchangeTimeZoneData tzRec in g_timeZoneInfo)
                if (tzRec.CountryID == p_country)
                    return tzRec;
            return null;
        }
        public static StockExchangeTimeZoneData FindTimeZoneRecByCompany(int p_companyID, DBManager p_dbManager)
        {
            HQCommon.MemTables.Company company;
            return !p_dbManager.MemTables.Company.TryGetValue(p_companyID, out company) ? null
                : FindTimeZoneRec(company.BaseCountryID.ToCountryID(), p_dbManager);
        }
        // Contains 1 item for every possible StockExchangeID
        // Designed to be thread safe!
        static StockExchangeTimeZoneData[] g_timeZoneInfo;
        public class StockExchangeTimeZoneData
        {
            public readonly StockExchangeID StockExchangeID;
            public readonly CountryID CountryID;
            public readonly TimeZoneID TimeZoneID;
            public readonly TimeZoneInfo TimeZoneInfo;
            long m_toUtcCache, m_toLocalCache;  // b0..b31:input   b32..b63:output

            /// <summary> Precondition: p_localTime.Kind != Utc. Thread safe. </summary>
            public DateTime ToUtc(DateTime p_localTime)
            {
                // GetUtcOffset() behaves differently when Kind=UTC is passed
                if (p_localTime.Kind == DateTimeKind.Utc)
                    throw new ArgumentException("Kind==UTC is not allowed");
                Measure(1, 0);
                long c = p_localTime.Ticks;
                int? i = DateTimeAsInt.CanBeRepresentedExactly(c);
                if (!i.HasValue)
                    return new DateTime(c - this.TimeZoneInfo.GetUtcOffset(p_localTime).Ticks, DateTimeKind.Utc);
                if (i.Value != unchecked((int)m_toUtcCache))
                { }
                else if (i.Value != unchecked((int)(c = m_toUtcCache)))   // check if other threads modified 'm_toUtcCache'
                    c = p_localTime.Ticks;
                else
                {
                    Measure(1, 1);
                    return new DateTimeAsInt((int)(c >> 32)).DateTimeAsUtc;
                }
                c -= this.TimeZoneInfo.GetUtcOffset(p_localTime).Ticks;
                m_toUtcCache = unchecked((uint)i.Value)     // writing 1 long is thread-safe
                    | ((long)DateTimeAsInt.CanBeRepresentedExactly(c).Value << 32);
                return new DateTime(c, DateTimeKind.Utc);
            }
            public static DateTime ToUtc(DateTime p_localTime, TimeZoneInfo p_timeZone)
            {
                // GetUtcOffset() behaves differently when Kind=UTC is passed
                if (p_localTime.Kind == DateTimeKind.Utc)
                    throw new ArgumentException("Kind==UTC is not allowed");
                return new DateTime(p_localTime.Ticks - p_timeZone.GetUtcOffset(p_localTime).Ticks, DateTimeKind.Utc);
            }
            /// <summary> Thread safe </summary>
            public DateTime ToLocal(DateTime p_timeUtc)
            {
                Measure(0, 0);
                long c = p_timeUtc.Ticks;
                int? i = DateTimeAsInt.CanBeRepresentedExactly(c);
                if (!i.HasValue)
                    return new DateTime(c + this.TimeZoneInfo.GetUtcOffset(new DateTime(c, DateTimeKind.Utc)).Ticks);  // Kind := Unspecified
                if (i.Value != unchecked((int)m_toLocalCache))
                { }
                else if (i.Value != unchecked((int)(c = m_toLocalCache)))
                    c = p_timeUtc.Ticks;
                else
                {
                    Measure(0, 1);
                    return new DateTimeAsInt((int)(c >> 32)).DateTime;  // Kind == Unspecified
                }
                c += this.TimeZoneInfo.GetUtcOffset(new DateTime(c, DateTimeKind.Utc)).Ticks;
                m_toLocalCache = unchecked((uint)i.Value)   // writing 1 long is thread-safe
                    | ((long)DateTimeAsInt.CanBeRepresentedExactly(c).Value << 32);
                return new DateTime(c);                     // Kind := Unspecified
            }
            public static DateTime ToLocal(DateTime p_timeUtc, TimeZoneInfo p_timeZone)
            {
                long t = p_timeUtc.Ticks;
                return new DateTime(t + p_timeZone.GetUtcOffset(new DateTime(t, DateTimeKind.Utc)).Ticks);  // Kind := Unspecified
            }

            internal StockExchangeTimeZoneData(StockExchangeID p_stockExchangeID,
                CountryID p_countryID, TimeZoneID p_timeZoneID, TimeZoneInfo p_timeZoneInfo)
            {
                StockExchangeID = p_stockExchangeID;
                CountryID       = p_countryID;
                TimeZoneID      = p_timeZoneID;
                TimeZoneInfo    = p_timeZoneInfo;
            }

            public override string ToString() { return StockExchangeID.ToString(); }    // for debugging
            public override int GetHashCode() { return ((int)TimeZoneID << 8) + (int)StockExchangeID; }
            public override bool Equals(object obj)
            {
                return (obj is StockExchangeTimeZoneData) && GetHashCode() == obj.GetHashCode();
            }

            [Conditional("MeasureToUtcToLocal")]
            static void Measure(byte p_toUtc, byte p_isSame)
            {
#if MeasureToUtcToLocal
                ++g_cnt[(p_toUtc << 1) + p_isSame];
            }
            static int[] g_cnt = new int[4];
            public static void PrintStatistics()
            {
                Utils.Logger.Verbose(
                    "ToUtc(): same input {0}/{1} cases; ToLocal(): same input {2}/{3} cases",
                    g_cnt[3], g_cnt[2], g_cnt[1], g_cnt[0]
                );
#endif
            }
        }

        public static bool IsTimeZoneInitialized
        {
            get { return g_timeZoneInfo != null; }
        }

        public static void InitTimeZoneData(object p_dbManager, bool p_forceReinit)
        {
            if (!p_forceReinit && g_timeZoneInfo != null)
            {
                g_InitTimeZoneData_chgntf.UpdateNowIfMissed(p_dbManager);
                return;
            }
            var timeZoneInfo = new Dictionary<HQCommon.TimeZoneID, System.TimeZoneInfo>();
            timeZoneInfo.AddRange(GetTimeZoneIDs());
            DBManager dbManager = DBManager.FromObject(p_dbManager, p_throwOnNull: false);
            bool offline = (dbManager == null || !dbManager.IsEnabled);
            if (offline)
                Utils.Logger.Warning("Warning: {0} falls back to hard-wired database StockExchangeIDs", Utils.GetCurrentMethodName(null, true));
            var stockExchanges = offline ? new[] {
                             new { StockExchangeID = StockExchangeID.NASDAQ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.NYSE  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.AMEX  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.PINK  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.CDNX  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.Canada      }
                            ,new { StockExchangeID = StockExchangeID.LSE   ,TimeZoneID = TimeZoneID.GMT ,CountryID = CountryID.UnitedKingdom}
                            ,new { StockExchangeID = StockExchangeID.XETRA ,TimeZoneID = TimeZoneID.CEST,CountryID = CountryID.Germany     }
                            ,new { StockExchangeID = StockExchangeID.CBOE  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.ARCA  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.BATS  ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            ,new { StockExchangeID = StockExchangeID.OTCBB ,TimeZoneID = TimeZoneID.EST ,CountryID = CountryID.UnitedStates}
                            }
                        : (dbManager.MemTables.IsLoaded(IntPtr.Size == 0 ? dbManager.MemTables.StockExchange : null)
                        ?   // use MemTables
                            from row in dbManager.MemTables.StockExchange.Values
                            select new {
                               StockExchangeID = (StockExchangeID)row.ID,
                               TimeZoneID = (TimeZoneID)row.TimeZone,
                               CountryID = (CountryID)row.CountryID
                            }
                        :
                            from row in dbManager.ExecuteQuery(
                               "SELECT ID, TimeZone, CountryID FROM StockExchange",
                               g_readingTimeoutSec
                            ).Rows.Cast<DataRow>()
                            select new {
                               StockExchangeID = Utils.ConvertTo<StockExchangeID>(row[0]),
                               TimeZoneID = Utils.ConvertTo<TimeZoneID>(row[1]),
                               CountryID = Utils.ConvertTo<CountryID>(row[2])
                            });
            StockExchangeID max = (StockExchangeID)0;
            StockExchangeTimeZoneData[] tmp = stockExchanges.Select(p_rec => {
                Utils.StrongAssert(0 <= p_rec.StockExchangeID && p_rec.StockExchangeID != StockExchangeID.Unknown);
                if (max < p_rec.StockExchangeID)
                    max = p_rec.StockExchangeID;
                TimeZoneID timeZoneId = p_rec.TimeZoneID;
                if (timeZoneId == TimeZoneID.Unknown)
                {
                    timeZoneId = TimeZoneID.EST;
                    Utils.Logger.Warning("Warning: TimeZone=Unknown for "
                        + "dbo.StockExchange.ID={0}, using TimeZone={1} instead",
                        p_rec.StockExchangeID, timeZoneId);
                }
                System.TimeZoneInfo tzInfo;
                timeZoneInfo.TryGetValue(timeZoneId, out tzInfo);
                if (tzInfo == null)
                    Utils.Logger.Warning("*** Warning: cannot find '{0}' {1} for"
                        + " {2}={3}", timeZoneId, typeof(TimeZoneID).Name,
                        typeof(StockExchangeID).Name, p_rec.StockExchangeID);
                return new StockExchangeTimeZoneData(p_rec.StockExchangeID, p_rec.CountryID,
                    timeZoneId, tzInfo);
            }).ToArray();
            var result = new StockExchangeTimeZoneData[(int)max + 1];
            foreach (StockExchangeTimeZoneData tzRec in tmp)
                result[(int)tzRec.StockExchangeID] = tzRec;

            Thread.MemoryBarrier();
            if (Interlocked.CompareExchange(ref g_timeZoneInfo, result, null) == null || !offline)
                g_InitTimeZoneData_chgntf.AddHandler(dbManager, (dbM,_) => InitTimeZoneData(dbM, true))
                    .SetDependency<MemTables.StockExchange>(ChangeNotification.Flags.AllTableEvents
                                                          | ChangeNotification.Flags.OfflineToOnlineTransition);

            // Initialize IsMarketOpenDayLoc(), too, to allow using it without DBManager from now on
            // (because g_timeZoneInfo[] and IsMarketOpenDayLoc() are used together usually)
            IsMarketOpenDayLoc(new DateTime(1901, 1, 1)/* Tuesday */, CountryID.UnitedStates, dbManager);
        }
        static StaticChangeHandlerWithWeakRef<DBManager> g_InitTimeZoneData_chgntf;


        /// <summary> Contains one item for every value of TimeZoneID </summary>
        static KeyValuePair<HQCommon.TimeZoneID, System.TimeZoneInfo>[] g_timeZoneIDs;
        static KeyValuePair<HQCommon.TimeZoneID, System.TimeZoneInfo>[] GetTimeZoneIDs()
        {
            if (g_timeZoneIDs == null)
            {
                var timeZoneInfo = new Dictionary<TimeZoneID, TimeZoneInfo>();
                foreach (var fieldInfo in typeof(HQCommon.TimeZoneID).GetFields())
                {
                    object[] a = !fieldInfo.IsStatic ? null
                        : fieldInfo.GetCustomAttributes(typeof(SystemTimeZoneIdAttribute), false);
                    TimeZoneInfo tzi = (a == null || a.Length == 0) ? null
                        : TimeZoneInfo.FindSystemTimeZoneById(((SystemTimeZoneIdAttribute)a[0]).Id);
                    if (tzi != null)
                        timeZoneInfo[(TimeZoneID)fieldInfo.GetValue(null)] = tzi;
                }
                g_timeZoneIDs = timeZoneInfo.ToArray();
            }
            return g_timeZoneIDs;
        }

        public static TimeZoneInfo GetTimeZoneInfo(this TimeZoneID p_tzId)
        {
            foreach (KeyValuePair<TimeZoneID, TimeZoneInfo> kv in GetTimeZoneIDs())
                if (kv.Key == p_tzId)
                    return kv.Value;
            return null;
        }

        /// <summary> Returns all {assetID,timeUtc} pairs for which timeUtc is
        /// within p_range and assetID is living at timeUtc (and is of type p_type
        /// if p_type.HasValue). Returned pairs are sorted by timeUtc, but assetIDs
        /// are in undefined order. timeUtc is local 00:00 converted to UTC.
        /// p_fromToUTC may be LivingAssets.Always.
        /// Precondition: LivingAssets.Init() was called </summary>
        // Arra szoktuk hasznalni ezt a fgv.t h egy randomAccess hdp-nek streaming szolgaltatast
        // implementaljunk.
        public static IEnumerable<KeyValuePair<IAssetID, DateTime>> GetAllMarketOpenDays(
            KeyValuePair<DateTime, DateTime> p_range, object p_dbManager, params AssetType[] p_types)
        {
            DateTime from = default(DateTime), to = p_range.Value;
            var q = new PriorityQueue<IGrouping<GetAllMarketOpenDaysHelper, IAssetID>>(4,
                (grp1, grp2) => grp1.Key.m_timeUtc.CompareTo(grp2.Key.m_timeUtc));
            q.AddRange(LivingAssets.GetAll(p_range, p_types).ToLookup(kv => {
                    if (LivingAssets.Equals(kv.Value, LivingAssets.Always)
                        || LivingAssets.Equals(kv.Value, LivingAssets.Never))
                    {}
                    else if (from == default(DateTime))
                    {
                        from = kv.Value.Key; to = kv.Value.Value;
                    }
                    else
                    {
                        if (kv.Value.Key < from) from = kv.Value.Key;
                        if (to < kv.Value.Value) to   = kv.Value.Value;
                    }
                    return new GetAllMarketOpenDaysHelper {
                        m_tzRec = DBUtils.FindTimeZoneRec(kv.Key.GetStockExchange(p_dbManager), p_dbManager)
                    };
                }, kv => kv.Key),
                p_enableSort: false
            );
            if (from < p_range.Key)
                from = p_range.Key;
            if (p_range.Value < to)
                to = p_range.Value;
            foreach (var grp in q)
            {
                grp.Key.m_dateLoc = grp.Key.m_tzRec.ToLocal(from);
                grp.Key.Step(TimeSpan.Zero, p_dbManager);
            }
            q.Sort();
            while (0 < q.Count)
            {
                IGrouping<GetAllMarketOpenDaysHelper, IAssetID> grp = q.Pop();
                if (to < grp.Key.m_timeUtc)
                    continue;
                foreach (IAssetID asset in grp)
                    if (LivingAssets.IsLiving(asset, grp.Key.m_timeUtc))
                        yield return new KeyValuePair<IAssetID, DateTime>(asset, grp.Key.m_timeUtc);
                grp.Key.Step(Utils.g_1day, p_dbManager);
                q.Add(grp);
            }
        }
        class GetAllMarketOpenDaysHelper
        {
            internal DBUtils.StockExchangeTimeZoneData m_tzRec;
            internal DateOnly m_dateLoc;
            internal DateTime m_timeUtc;
            public override bool Equals(object obj)
            {
                return (obj is GetAllMarketOpenDaysHelper)
                    && ((GetAllMarketOpenDaysHelper)obj).m_tzRec.TimeZoneInfo.Equals(m_tzRec.TimeZoneInfo);
            }
            public override int GetHashCode() { return m_tzRec.TimeZoneInfo.GetHashCode(); }
            internal void Step(TimeSpan p_timeSpan, object p_dbManager)
            {
                m_dateLoc = m_dateLoc.AddMarketTimeLoc2(p_timeSpan, m_tzRec.CountryID, p_dbManager);
                m_timeUtc = m_tzRec.ToUtc(m_dateLoc);
            }
        }

        #endregion

        #region Create Portfolio
        /// <summary> For debugging: if passed to WritePortfolioIntoDatabase() as
        /// p_userName, the database won't be modified. Simulates AllUser </summary>
        public const string FakeUsername_SimulateWritePortfolioIntoDatabase = "¶ Simulate WritePortfolioIntoDatabase() ¶";

        /// <summary> Creates a new portfolio with p_portfolioName (or re-creates 
        /// the existing one) containing the transaction records specified by p_transactions.
        /// </summary>
        public static Portfolio WritePortfolioIntoDatabase(IEnumerable<PortfolioItem> p_transactions,
            DBManager p_dbManager, string p_portfolioName, string p_userName,
            System.Xml.XmlElement p_note)
        {
            if (p_transactions == null || p_portfolioName == null)
                return null;

            if (p_note != null && p_note.Name != Portfolio.NoteXmlTag)
                throw new ArgumentException(String.Format("<{0}>: invalid XmlElement for Note."
                + " Should be <{1}>", p_note.Name, Portfolio.NoteXmlTag));

            string name = p_portfolioName;
            int i = name.LastIndexOf(FolderPathSeparator);
            if (i >= 0)
            {
                name = name.Substring(i + 1);
                if (name.Length == 0)
                    throw new ArgumentException("Invalid portfolio name: " + p_portfolioName);
            }

            bool isSimulatingOnly = (p_userName == FakeUsername_SimulateWritePortfolioIntoDatabase);
            Utils.ProduceOnce(ref p_transactions);
            // default user if the specified userName not found
            string defaultUser = HQUserID.AllUser.ToString();
            if (String.IsNullOrEmpty(p_userName) || isSimulatingOnly)
                p_userName = defaultUser;

            Utils.Logger.Info("Writing portfolio to database{1}: {0}", p_portfolioName, isSimulatingOnly ? " (simulation only)" : null);
            var pars = new List<System.Data.Common.DbParameter>(2);
            pars.Add(new SqlParameter("@username", p_userName));
            HQUserID userID = Utils.ConvertTo<HQUserID>(p_dbManager.ExecuteSqlCommand(DBType.Remote, String.Format(
                "SELECT ISNULL( (SELECT ID FROM HQUser WHERE UserName=@username),"
                            + " (SELECT ID FROM HQUser WHERE UserName='{0}'))",
                defaultUser), CommandType.Text, pars, SqlCommandReturn.SimpleScalar,
                g_modifyPortfolioItemsTimeoutSec));

            Portfolio result;
            if (isSimulatingOnly)
            {
                result = new Portfolio {    // ID == ParentFolderID == 0
                    Name = name,
                    UserID = userID,
                    LastWriteTime = DateTime.UtcNow,
                    Note = p_note,
                    Transactions = p_transactions
                };
                FileSystemItem fsItem;
                if (FindPath(p_portfolioName, userID, out fsItem, p_dbManager, false))
                {
                    Utils.StrongAssert(fsItem.TypeID == FileSystemItemTypeID.Portfolio,
                        "Cannot create portfolio because the specified FileSystemItem"
                        + " exists, but not a portfolio: '{0}'", p_portfolioName);
                    result.ID = fsItem.ID;
                    result.ParentFolderID = fsItem.ParentFolderID;
                }
            }
            else
            {
                FileSystemItem fsItem;
                bool exists = EnsurePath(p_portfolioName, userID, out fsItem, p_dbManager, true);
                Utils.StrongAssert(!exists || fsItem.TypeID == FileSystemItemTypeID.Portfolio,
                    "Cannot create portfolio because the specified FileSystemItem"
                    + " exists, but is not a portfolio: '{0}'", p_portfolioName);
                result = CreateOrUpdatePortfolioOrQuickfolio(p_dbManager, exists ? fsItem.ID : -1,
                    fsItem == null ? -1 : fsItem.ID, FileSystemItemTypeID.Portfolio,
                    userID, 0 /* Portfolio.Flags */, name, p_note, p_transactions);
            }
            return result;
        }

        /// <summary> Precondition: the p_parentFolderID FileSystemItem exists,
        /// belongs to p_userId and has no child named p_name. </summary>
        public static Portfolio CreatePortfolio(DBManager p_dbManager,
            int p_parentFolderID, HQUserID p_userId, byte p_flags, string p_name,
            System.Xml.XmlElement p_note, IEnumerable<PortfolioItem> p_transactions)
        {
            return CreateOrUpdatePortfolioOrQuickfolio(p_dbManager, -1, p_parentFolderID, FileSystemItemTypeID.Portfolio,
                p_userId, p_flags, p_name, p_note, p_transactions);
        }

        /// <summary> Precondition: the p_portfolioId portfolio exists (its
        /// TypeID is Portfolio), its name is already p_name and belongs to
        /// p_userId. </summary>
        public static Portfolio OverwritePortfolio(DBManager p_dbManager,
            int p_portfolioId, HQUserID p_userId, byte p_flags, string p_name,
            System.Xml.XmlElement p_note, IEnumerable<PortfolioItem> p_transactions)
        {
            if (p_portfolioId < 0)
                throw new ArgumentException();
            return CreateOrUpdatePortfolioOrQuickfolio(p_dbManager, p_portfolioId, 0, FileSystemItemTypeID.Portfolio,
                p_userId, p_flags, p_name, p_note, p_transactions);
        }

        /// <summary> Precondition: the p_parentFolderID FileSystemItem exists,
        /// belongs to p_userId and has no child named p_name. </summary>
        public static Portfolio CreateQuickfolio(DBManager p_dbManager,
            int p_parentFolderID, HQUserID p_userId, byte p_flags, string p_name,
            System.Xml.XmlElement p_note, IEnumerable<IAssetID> p_assets)
        {
            return CreateOrUpdatePortfolioOrQuickfolio(p_dbManager, -1, p_parentFolderID, FileSystemItemTypeID.Quickfolio,
                p_userId, p_flags, p_name, p_note, p_assets);
        }

        /// <summary> Negative p_pqfolioID means "create new".
        /// p_parentFolderID and p_portfolioType are used in this case only, otherwise ignored. 
        /// </summary>
        static Portfolio CreateOrUpdatePortfolioOrQuickfolio<T>(DBManager p_dbManager,
            int p_pqfolioID, int p_parentFolderID, FileSystemItemTypeID p_portfolioType,
            HQUserID p_userId, byte p_flags, string p_name, System.Xml.XmlElement p_note,
            IEnumerable<T> p_items)
        {
            bool p = typeof(PortfolioItem).IsAssignableFrom(typeof(T));
            if (!p && !typeof(IAssetID).IsAssignableFrom(typeof(T)))
                throw new ArgumentException(typeof(T) + " should be " + typeof(PortfolioItem) + " or " + typeof(IAssetID));
            const string NewLn = "\r\n";
            var result = new Portfolio {
                TypeID = p_portfolioType,           // throws ArgumentException if p_portfolioType is invalid
                Transactions = p ? (IEnumerable<PortfolioItem>)p_items : null,
                Flags = p_flags
            };
            var parameters = new List<System.Data.Common.DbParameter> {
                new SqlParameter("@name", p_name),
                new SqlParameter("@note", CheckLengthOfNote<FileSystemItem>(p_note, DBNull.Value, p_dbManager, "FileSystemItem.Name=" + p_name))
            };
            string tSqlBatch;
            if (0 <= p_pqfolioID)                   // overwriting an existing portfolio/quickfolio
                tSqlBatch = Utils.FormatInvCult(
                    "SET XACT_ABORT ON;" + NewLn +
                    "BEGIN TRANSACTION;" + NewLn +
                    "DELETE FROM {0}folioItem WHERE {0}folioID = {1};" + NewLn +
                    AppendPortfolioOrQuickfolioItems(p_items, p_pqfolioID.ToString(Utils.InvCult), parameters, p_dbManager) + NewLn +
                    "UPDATE FSPortfolio SET Flags = {2} WHERE FileSystemItemID={1};" + NewLn +
                    "UPDATE FileSystemItem SET LastWriteTime = GETUTCDATE(),"
                    + " Note = @note WHERE ID = {1};" + NewLn +
                    "COMMIT TRANSACTION;" + NewLn +
                    "SELECT * FROM FileSystemItem WHERE ID = {1};",
                    p ? "Port" : "Quick", p_pqfolioID, p_flags);
            else                                    // creating new
                tSqlBatch = Utils.FormatInvCult(
                    "SET XACT_ABORT ON;" + NewLn +
                    "BEGIN TRANSACTION;" + NewLn +
                    "DECLARE @tmp TABLE (id INT NOT NULL);" + NewLn +
                    "INSERT INTO FileSystemItem(Name,UserID,TypeID,ParentFolderID,Note)"
                    + " OUTPUT INSERTED.ID INTO @tmp VALUES (@name,{0},{1},{2},@note);" + NewLn +
                    "DECLARE @id INT = (SELECT id FROM @tmp);" + NewLn +
                    (p ? "INSERT INTO FSPortfolio(FileSystemItemID,Flags) VALUES (@id,{3});" + NewLn : null) +
                    AppendPortfolioOrQuickfolioItems(p_items, "@id", parameters, p_dbManager) + NewLn +
                    "COMMIT TRANSACTION;" + NewLn +
                    "SELECT * FROM FileSystemItem WHERE ID = @id;",
                    (int)p_userId, (byte)p_portfolioType, p_parentFolderID, p_flags);

            DataRow fsiRow = (p_dbManager.ExecuteSqlCommandRemoteSync(tSqlBatch, CommandType.Text,
                parameters, SqlCommandReturn.Table, g_modifyPortfolioItemsTimeoutSec) as DataTable).Rows[0];
            LoadFsiRow(result, fsiRow);             // sets result.TypeID again + sets result.ID

            Utils.StrongAssert(result.ID == p_pqfolioID || p_pqfolioID < 0);
            AnnouncePQInsertOrUpdate(p_pqfolioID, p);
            return result;
        }
        const int g_modifyPortfolioItemsTimeoutSec = 10 * 60;
        const int g_readingTimeoutSec = 10 * 60;

        /// <summary> Negative p_pqfolioId indicates insertion (new *folio was created).
        /// Otherwise update occurred. Note: adding items to an existing *folio is an 'update'.
        /// </summary>
        static void AnnouncePQInsertOrUpdate(int p_pqfolioId, bool p_isPortfolio)
        {
            if (0 <= p_pqfolioId)   // update (overwrite)
            {
                ChangeNotification.OnMemTableChange(m => m.FileSystemItem,                      p_pqfolioId);
              //if (p_isPortfolio)  ChangeNotification.OnMemTableChange(m => m.FSPortfolio,     p_pqfolioId);
                if (p_isPortfolio)  ChangeNotification.OnMemTableChange(m => m.PortfolioItem,   p_pqfolioId);
                else                ChangeNotification.OnMemTableChange(m => m.QuickfolioItem,  p_pqfolioId);
            }
            else                    // insert
            {
                ChangeNotification.OnRowInsert(m => m.FileSystemItem);
              //if (p_isPortfolio)  ChangeNotification.OnRowInsert(m => m.FSPortfolio);
                if (p_isPortfolio)  ChangeNotification.OnRowInsert(m => m.PortfolioItem);
                else                ChangeNotification.OnRowInsert(m => m.QuickfolioItem);
            }
        }

        /// <summary> T is any type whose name is a table, e.g. "PortfolioItem" or "FileSystemItem" </summary>
        public static object CheckLengthOfNote<T>(object p_note, object p_nullValue, object p_dbManager, string p_infoToLog)
        {
            string noteStr;
            if (p_note is System.Xml.XmlElement)
                noteStr = ((System.Xml.XmlElement)p_note).OuterXml;
            else if (p_note == null)
                noteStr = null;
            else
                noteStr = p_note.ToString();
            if (String.IsNullOrEmpty(noteStr))
                return p_nullValue;

            string encoded = EncodeToVARCHAR(noteStr);
            int maxLen = NoteColumnOf<T>.g_columnLengthInDb;
            if (maxLen == 0 && p_dbManager != null)
            {
                maxLen = Convert.ToInt32(DBManager.FromObject(p_dbManager, true).ExecuteSqlCommand(
                    "SELECT CHARACTER_MAXIMUM_LENGTH FROM INFORMATION_SCHEMA.COLUMNS"
                    + " WHERE TABLE_NAME='" + typeof(T).Name + "' AND COLUMN_NAME='Note'",
                    CommandType.Text, null, SqlCommandReturn.SimpleScalar));
                Utils.DebugAssert(maxLen != 0);
                NoteColumnOf<T>.g_columnLengthInDb = maxLen;
            }
            if (maxLen != 0 && maxLen < encoded.Length)
                Utils.Logger4<T>().Error("*** Warning: log message is too long for {1}.Note, will be truncated!"
                    + " Additional info: {2}. Before truncation ({3} chars instead of {4}):{0}{5}",
                    Environment.NewLine, typeof(T).Name, p_infoToLog, encoded.Length, maxLen, noteStr);
            return encoded;
        }
        static class NoteColumnOf<T> { internal static int g_columnLengthInDb; }

        /// <summary> Returns a string containing T-SQL commands for appending p_items to the
        /// [port|quick]folio specified by p_pqfolioID. Items must be PortfolioItem or IAssetID
        /// (for quickfolios). The generated batch may use parameters. These are returned in
        /// p_parameters[] (must not be null). </summary>
        public static string AppendPortfolioOrQuickfolioItems(System.Collections.IEnumerable p_items,
            string p_pqfolioID, List<System.Data.Common.DbParameter> p_parameters, object p_dbManager)
        {
            if (p_items == null)
                return null;
            var invCult = System.Globalization.CultureInfo.InvariantCulture;
            StringBuilder sb = new StringBuilder();
            if (!(p_items is IEnumerable<PortfolioItem>))
            {
                foreach (IAssetID item in p_items)
                    sb.AppendLine(String.Format(invCult, "INSERT INTO QuickfolioItem"
                        + " (QuickfolioID,AssetTypeID,AssetSubTableID) VALUES ({0},{1},{2});",
                        p_pqfolioID, (int)((IAssetID)item).AssetTypeID, ((IAssetID)item).ID));
                return sb.ToString();
            }
            string noteLogStr = "PortfolioID=" + p_pqfolioID.ToString(invCult);
            const string sep = "\u0014";    // DC4, "Device Control 4" control character, within the 0..127 range
                                            // This separator allows newline/tab/etc in items
            foreach (PortfolioItem item in p_items)
            {
                if (0 < sb.Length)
                    sb.Append(sep);
                sb.AppendFormat(invCult, "{1}{0}{2}{0}{3}{0}{4}{0}{5}{0}{6:yyyy-MM-ddTHH:mm:00}{0}{7}",
                    sep, (int)item.TransactionType, (int)item.AssetTypeID, item.SubTableID, item.Volume, item.Price,
                    item.TimeUtc, CheckLengthOfNote<PortfolioItem>(item.NoteXml, null, p_dbManager, noteLogStr));
            }
            if (sb.Length == 0)
                return String.Empty;
            p_parameters.Add(new SqlParameter("@p_str", sb.ToString()));
            p_parameters.Add(new SqlParameter("@p_ch", sep));
            return String.Format(invCult,
@"INSERT INTO PortfolioItem (PortfolioID,TransactionType,AssetTypeID,AssetSubTableID,Volume,Price,Date,Note) 
SELECT {0},[0],[1],[2],[3],[4],[5],NULLIF([6],'') FROM (
  SELECT (SeqNr / 7) AS R, (SeqNr % 7) AS M, Item
  FROM dbo.SplitStringToTable(@p_str, @p_ch)
) P PIVOT (MIN(Item) FOR M IN ([0],[1],[2],[3],[4],[5],[6])) AS S;", p_pqfolioID);
        }

        /// <summary> Works asynchronously when p_callback != null </summary>
        public static void AppendPortfolioOrQuickfolioItems(System.Collections.IEnumerable p_items,
            int p_pqfolioID, DBManager p_dbManager, Action<DataTable, Exception> p_callback)
        {
            var @params = new List<System.Data.Common.DbParameter>();
            string fsId = p_pqfolioID.ToString(Utils.InvCult);
            bool isPortfolio = (p_items is IEnumerable<PortfolioItem>);
            string sql = AppendPortfolioOrQuickfolioItems(p_items, fsId, @params, p_dbManager);
            if (String.IsNullOrEmpty(sql) && p_callback != null)
                p_callback(new DataTable(), null);
            else if (!String.IsNullOrEmpty(sql))
            {
                if (p_pqfolioID < 0)
                    throw new ArgumentOutOfRangeException();
                sql = "SET XACT_ABORT ON; BEGIN TRANSACTION;" + Environment.NewLine + sql + Environment.NewLine
                    + "UPDATE FileSystemItem SET LastWriteTime = GETUTCDATE() WHERE ID = " + fsId + ";"
                    + Environment.NewLine + "COMMIT TRANSACTION;";
                if (p_callback == null)
                {
                    p_dbManager.ExecuteSqlCommandRemoteSync(sql, CommandType.Text, @params, SqlCommandReturn.None, g_modifyPortfolioItemsTimeoutSec);
                    AnnouncePQInsertOrUpdate(p_pqfolioID, isPortfolio);
                }
                else
                {
                    p_dbManager.ExecuteSqlCommandAsync(DBType.Remote, sql, CommandType.Text, @params,
                        (p_table, p_exception) => {
                            if (p_exception == null)
                                AnnouncePQInsertOrUpdate(p_pqfolioID, isPortfolio);
                            p_callback(p_table, p_exception);
                        },
                        g_modifyPortfolioItemsTimeoutSec);
                }
            }
        }
        #endregion

        #region FileSystemItem paths
        /// <summary> Creates the folder structure specified in p_fullPath into
        /// the given user's file system. The last component of p_fullPath, if 
        /// not "", must be a non-folder item. Does not create this terminal
        /// FileSystemItem, but checks its existence. If exists, reads it into
        /// p_item and returns true. Otherwise returns false and returns the
        /// parent folder in p_item (null means the root). </summary>
        public static bool EnsurePath(string p_fullPath, HQUserID p_userID,
            out FileSystemItem p_item, DBManager p_dbManager, bool p_forceRemoteLookup)
        {
            return FindOrCreatePath(p_fullPath, p_userID, true, out p_item,
                p_dbManager, p_forceRemoteLookup);
        }

        /// <summary> Returns true if p_fullPath is found in the given user's
        /// file system; p_item receives the FileSystemItem. Otherwise p_item
        /// receives the deepest folder that is found (null means the root). </summary>
        public static bool FindPath(string p_fullPath, HQUserID p_userID,
            out FileSystemItem p_item, DBManager p_dbManager, bool p_forceRemoteLookup)
        {
            return FindOrCreatePath(p_fullPath, p_userID, false, out p_item,
                p_dbManager, p_forceRemoteLookup);
        }

        /// <summary>Returns true if found (not created) </summary>
        /// <param name="p_fullPath">Last component must not be a folder name (but may be "")</param>
        static bool FindOrCreatePath(string p_fullPath, HQUserID p_userID, bool p_createIfMissing,
            out FileSystemItem p_item, DBManager p_dbManager, bool p_forceRemoteLookup)
        {
            const byte FOLDER = (byte)FileSystemItemTypeID.Folder;

            int parentId = -1;
            string[] pathItems = p_fullPath.Split(FolderPathSeparator);

            p_item = new FileSystemItem { ID = -1, ParentFolderID = -1 };
            bool exists = true;
            for (int i = 0; i < pathItems.Length; ++i)
            {
                bool isFolder = (i < pathItems.Length - 1);
                if (!isFolder && pathItems[i].Length == 0)
                    break;                                  // p_fullPath ends with separator
                Utils.DebugAssert(pathItems[i].Length > 0);
                if (exists)
                {
                    System.Collections.IEnumerable rows = (p_forceRemoteLookup)
                        ? (p_dbManager.ExecuteSqlCommand(DBType.Remote,
                            Utils.FormatInvCult("SELECT * FROM FileSystemItem WHERE ParentFolderID={0}"
                                + (p_userID == HQUserID.Unknown ? String.Empty : " AND UserID={1}")
                                + " AND (TypeID{2}{3}) AND Name=@name",
                                parentId, (int)p_userID, isFolder ? "=" : "!=", FOLDER),
                            CommandType.Text, new[] { new SqlParameter("@name", pathItems[i]) },
                            SqlCommandReturn.Table, g_modifyPortfolioItemsTimeoutSec) as DataTable).Rows
                        : p_dbManager.MemTables.FileSystemItem.GetItemsByParentID(parentId, p_userID).Where(fsRow =>
                                (fsRow.TypeID == FileSystemItemTypeID.Folder) == isFolder
                                && fsRow.Name == pathItems[i]) as System.Collections.IEnumerable;
                    exists = false;
                    foreach (object row in rows)
                    {
                        var fsi = row as HQCommon.MemTables.FileSystemItem;
                        if (exists)
                            Utils.Logger.Error("*** ERROR: identical Name, ParentFolderID, UserID"
                                + " in multiple rows: FileSystemItem.ID={0},{1}",
                                p_item.ID, (fsi != null) ? fsi.ID : ((DataRow)row)["ID"]);
                        if (fsi != null)
                            LoadFsiRow(p_item, fsi);
                        else
                            LoadFsiRow(p_item, (DataRow)row);
                        exists = true;
                    }
                }
                if (!exists && isFolder)
                {
                    if (!p_createIfMissing)
                        break;
                    // create pathItems[i] under parentId
                    // assign the new item to result (p_item)
                    DataRow row = (p_dbManager.ExecuteSqlCommand(DBType.Remote, Utils.FormatInvCult(
                        "INSERT INTO FileSystemItem (Name,UserID,TypeID,ParentFolderID)"
                        + " OUTPUT INSERTED.* VALUES (@name,{0},{1},{2});",
                        (int)p_userID, FOLDER, parentId), CommandType.Text,
                        new[] { new SqlParameter("@name", pathItems[i]) }, SqlCommandReturn.Table,
                        g_modifyPortfolioItemsTimeoutSec) as DataTable)
                        .Rows.OfType<DataRow>().SingleOrDefault();
                    LoadFsiRow(p_item, row);
                    ChangeNotification.OnRowInsert(m => m.FileSystemItem);
                }
                parentId = p_item.ID;
            }
            if (p_item.ID == -1 && p_item.ParentFolderID == -1)
                p_item = null;
            return exists;
        }

        //public static string GetFullPath(int p_fsId, bool p_includeFile, DBManager p_dbManager)
        //public static string GetFolderPath(this FileSystemItem p_fsItem, DBManager p_dbManager)
        #endregion

        #region Load portfolio
        public static T LoadFsiRow<T>(this T p_item, DataRow p_row) where T : FileSystemItem
        {
            var invCult = System.Globalization.CultureInfo.InvariantCulture;
            p_item.ID = Convert.ToInt32(p_row["ID"], invCult);
            p_item.Name = Convert.ToString(p_row["Name"], invCult);
            p_item.UserID = Utils.ConvertTo<HQUserID>(p_row["UserID"]);
            p_item.TypeID = (FileSystemItemTypeID)Convert.ToByte(p_row["TypeID"], invCult);
            p_item.ParentFolderID = Convert.ToInt32(p_row["ParentFolderID"], invCult);
            p_item.LastWriteTime = (DateTime)p_row["LastWriteTime"];
            p_item.NoteXmlString = DecodeFromVARCHAR(Utils.DBNullCast<string>(p_row["Note"]));
            return p_item;
        }

        public static T LoadFsiRow<T>(this T p_item, HQCommon.MemTables.FileSystemItem p_fsRow)
            where T : FileSystemItem
        {
            p_item.ID = p_fsRow.ID;
            p_item.Name = p_fsRow.Name;
            p_item.UserID = p_fsRow.UserID;
            p_item.TypeID = (FileSystemItemTypeID)p_fsRow.TypeID;
            p_item.ParentFolderID = p_fsRow.ParentFolderID;
            p_item.LastWriteTime = p_fsRow.LastWriteTime;
            p_item.NoteXmlString = p_fsRow.Note == null ? null : DecodeFromVARCHAR(p_fsRow.Note);
            return p_item;
        }

        /// <summary> Postcondition: Portfolio.Transactions != null, an IList&lt;PortfolioItem&gt; </summary>
        public static Portfolio LoadPortfolio(this DBManager p_dbManager, int p_portfolioId, bool p_forceRemote = false)
        {
            return DBUtils.LoadPortfolio(p_portfolioId, p_dbManager, p_forceRemote);
        }

        /// <summary> Postcondition: Portfolio.Transactions != null, an IList&lt;PortfolioItem&gt; </summary>
        public static Portfolio LoadPortfolio(int p_portfolioId,
            DBManager p_dbManager, bool p_forceRemote = false)
        {
            if (p_dbManager == null)
                throw new NullReferenceException();
            MemoryTables m = p_dbManager.MemTables;
            bool useMemCache = (!p_forceRemote &&
                (/*m.IsLoaded(m == null ? m.FSPortfolio    : null)      // intentionally passing 'null' to IsLoaded()
               ||*/m.IsLoaded(m == null ? m.FileSystemItem : null)      // intentionally passing 'null' to IsLoaded()
                || m.IsLoaded(m == null ? m.PortfolioItem  : null)));   // intentionally passing 'null' to IsLoaded()

            Portfolio result = null;
            if (useMemCache)
            {
                //HQCommon.MemTables.FSPortfolio prow;
                //if (!m.FSPortfolio.TryGetValue(p_portfolioId, out prow))
                //    return null;
                HQCommon.MemTables.FileSystemItem fsRow;
                if (!m.FileSystemItem.TryGetValue(p_portfolioId, out fsRow)
                    || fsRow.TypeID != FileSystemItemTypeID.Portfolio)
                    return null;
                result = LoadFsiRow(new Portfolio() /*{ Flags = prow.Flags }*/, fsRow);
                result.Transactions = m.PortfolioItem[p_portfolioId].AsIList()
                    .SelectList((_,item) => new PortfolioItem(item));
            }
            else
            {
                foreach (DataRow row in p_dbManager.ExecuteQuery(
                    "SELECT * FROM FileSystemItem"
                    + " LEFT JOIN FSPortfolio ON FSPortfolio.FileSystemItemID = FileSystemItem.ID"
                    + " WHERE ID=" + p_portfolioId.ToString(Utils.InvCult), g_readingTimeoutSec).Rows)
                    result = LoadFsiRow(new Portfolio { Flags = Utils.DBNullCast(row["Flags"], (byte)0) }, row);
                if (result == null || result.TypeID != FileSystemItemTypeID.Portfolio)
                    return null;
                var kv_arg = new KeyValuePair<int, DBManager>(result.ID, p_dbManager);
                result.Transactions = DBManager.ExecuteWithRetry(kv_arg, (kv, dummy) => {
                    var items = new FastGrowingList<PortfolioItem>();
                    foreach (System.Data.Common.DbDataReader row in kv.Value.ExtremeQuery(
                        "SELECT ID,AssetTypeID,AssetSubTableID,TransactionType,Date,Volume,Price,Note"
                        + " FROM PortfolioItem WHERE PortfolioID = " + kv.Key.ToString(Utils.InvCult),     // not sorted!
                        g_readingTimeoutSec))
                    {
                        items.Add(new PortfolioItem {
                            ID              = row.GetInt32(0),
                            AssetTypeID     = Utils.ConvertTo<AssetType>(row[1]),
                            SubTableID      = row.GetInt32(2),
                            TransactionType = Utils.ConvertTo<PortfolioItemTransactionType>(row[3]),
                            TimeUtc         = row.GetDateTime(4),
                            Volume          = Utils.DBNullCast(row[5], 0),
                            Price           = row.IsDBNull(6) ? double.NaN : (double)(decimal)row.GetFloat(6),
                            NoteXml         = DecodeFromVARCHAR(Utils.DBNullCast<string>(row[7]))
                        });
                    }
                    return items;
                });
            }
            result.Transactions = result.Transactions.AsIList();
            return result;
        }

        /// <summary> p_ctx.DBManager must be non-null, other fields of p_ctx may be null.
        /// p_itemLoader may be null. Postcondition: Portfolio.Transactions
        /// is a List&lt;PortfolioItem&gt;, not null. The returned
        /// IEnumerable&lt;PortfolioItemPlus&gt; is never null. </summary>
        public static KeyValuePair<Portfolio, IList<PortfolioItemPlus>> FillAdditionalPipOrPidFields(int p_portfolioId,
            MiniCtx p_ctx, PortfolioItemLoadingHelper p_itemLoader = null, bool p_forceRemote = false)
        {
            Portfolio p = LoadPortfolio(p_portfolioId, p_ctx.DBManager(), p_forceRemote);
            var pips = (p == null) ? (IList<PortfolioItemPlus>)Enumerable.Empty<PortfolioItemPlus>()
                : FillAdditionalPipOrPidFields(p.Transactions, p_ctx.GetContext(), p_itemLoader, p_forceRemote);
            return new KeyValuePair<Portfolio, IList<PortfolioItemPlus>>(p, pips);
        }

        public delegate PortfolioItemPlus PortfolioItemLoadingHelper(PortfolioItemPlus p_item,
            CurrencyID p_currency, StockExchangeID p_stockExchangeId, string p_name, string p_ticker);

        /// <summary> Creates PortfolioItemPlus from every PortfolioItem, preserving order.
        /// Fills PortfolioItemPlus.CurrencyID, .StockExchangeID fields appropriately.
        /// p_ctx.DBManager is required, other fields may be null.
        /// p_itemLoader may be null. If specified, can be used to fill Name and Ticker
        /// fields as well (e.g. create PortfolioItemData instances).
        /// </summary>
        public static AbstractList<PortfolioItemPlus> FillAdditionalPipOrPidFields(
            IEnumerable<PortfolioItem> p_transactions, IContext p_ctx,
            PortfolioItemLoadingHelper p_itemLoader = null, bool p_forceRemote = false)
        {
            DBManager dbManager = p_ctx.DBManager();
            MemoryTables m = dbManager.MemTables;
            var result = new HQCommon.Screener.AssetTypeChains<PortfolioItemPlus>(
                                Math.Max(1, Utils.TryGetCount(p_transactions)));
            string name = null, ticker = null;
            bool needNameTicker = true;
            if (p_itemLoader == null)
            {
                // 'name' and 'ticker' are not needed for the default item loader
                needNameTicker = (p_itemLoader = DefaultItemLoader) == null;
            }
            ITickerProvider tickerProvider = needNameTicker ? p_ctx.TickerProvider : null;
            foreach (PortfolioItem pi in p_transactions.EmptyIfNull())
            {
                CurrencyID currency = CurrencyID.Unknown;
                var stockExchangeID = StockExchangeID.Unknown;
                name = ticker = null;

                bool requiresRemoteQuery = p_forceRemote;
                if (!p_forceRemote) switch (pi.AssetTypeID)
                {
                    case AssetType.HardCash :
                        HQCommon.MemTables.Currency cRow;
                        currency = (CurrencyID)pi.SubTableID;
                        if (needNameTicker && m.Currency.TryGetValue(pi.SubTableID, out cRow))
                            name = ComposeCurrencyNameAndTicker(cRow, out ticker);
                        break;
                    case AssetType.Stock :
                        currency = GetCurrencyID(pi.AssetTypeID, pi.SubTableID, dbManager);
                        HQCommon.MemTables.Stock stockRow;
                        if (m.Stock.TryGetValue(pi.SubTableID, out stockRow))
                        {
                            stockExchangeID = stockRow.StockExchangeID ?? stockExchangeID;
                            if (!needNameTicker || (requiresRemoteQuery |= (tickerProvider == null)))
                                break;
                            ticker = tickerProvider.GetTicker(AssetType.Stock, pi.SubTableID, pi.TimeUtc, p_nullIfUnknown: false);
                            //requiresRemoteQuery = (ticker != stockRow.Ticker);  // fall back to remote query, in order to get historical stock.Name
                            //if (!requiresRemoteQuery)                             commented out because of the HACK there (see below)
                                name = (stockRow.Name == null) ? null : stockRow.Name;
                        }
                        break;
                    case AssetType.Option :
                        if (p_ctx.OptionProvider == null)
                            requiresRemoteQuery = true;
                        else
                            GetOptionAdditionalFieldsFromMemTables(pi.SubTableID, pi.TimeUtc, p_ctx, needNameTicker,
                                out stockExchangeID, out currency, out name, out ticker);
                        break;
                    case AssetType.Futures :
                        if (p_ctx.FuturesProvider == null)
                            requiresRemoteQuery = true;
                        else
                        {
                            var futures = p_ctx.FuturesProvider.GetFuturesById(pi.SubTableID);
                            if (futures.HasValue)
                            {
                                stockExchangeID = futures.Value.StockExchangeID;
                                currency = (CurrencyID)futures.Value.CurrencyID;
                                if (!needNameTicker)
                                    break;
                                ticker = null;
                                switch (futures.Value.UnderlyingAssetType)
                                {
                                    case AssetType.HardCash :
                                        if (m.Currency.TryGetValue(futures.Value.UnderlyingSubTableID, out cRow))
                                            ComposeCurrencyNameAndTicker(cRow, out ticker);
                                        else
                                            ticker = DBUtils.DefaultAssetIDString(AssetType.HardCash, futures.Value.UnderlyingSubTableID);
                                        break;
                                    case AssetType.BenchmarkIndex :
                                    case AssetType.Stock :
                                        if (tickerProvider != null)
                                            ticker = tickerProvider.GetTicker(futures.Value.UnderlyingAssetType, futures.Value.UnderlyingSubTableID,
                                                pi.TimeUtc, p_nullIfUnknown: false);
                                        break;
                                }
                                if (String.IsNullOrEmpty(ticker))
                                    requiresRemoteQuery = true;
                                else
                                {
                                    m.Currency.TryGetValue((int)futures.Value.CurrencyID, out cRow);
                                    // Now 'ticker' is the ticker of the underlying. Use it to compose Futures.Name
                                    name = ComposeFuturesName(ticker, futures.Value.ExpirationDate, cRow.Sign);
                                    // ticker := Futures.Ticker
                                    ticker = ComposeFuturesTicker(futures.Value, ticker, tickerProvider);
                                }
                            }
                        }
                        break;
                    default:
                        requiresRemoteQuery = true;
                        break;
                }
                var pip = new PortfolioItemPlus(pi, currency, stockExchangeID);
                if (!requiresRemoteQuery && needNameTicker)
                    pip = p_itemLoader(pip, currency, stockExchangeID, name, ticker);
                result.Add(pi.AssetID, pip, requiresRemoteQuery);
            }
            foreach (AssetType at in result.GetAssetTypes())
            {
                // sql:   SubtableID, StockExchangeID, CurrencyID [, Name, Ticker]  (when qXchg == null)
                //        Idx,        CurrencyID [, ...]                            (otherwise)
                // qXchg: SubtableID, StockExchangeID
                string sql, qXchg = null;
                const string FROM_splitStringToTable = @" FROM (
SELECT CONVERT(DATE,LEFT(Item,{1})) [Date], CONVERT(INT,SUBSTRING(Item,{1}+2,{2})) [Idx],
CONVERT(INT,SUBSTRING(Item,{1}+{2}+3,10)) [ID]
FROM dbo.SplitStringToTable('{0}',',')) tmp ";
                Func<DataRow, KeyValuePair<string, string>> nameTickerCalculator = null;
                switch (at)
                {
                    case AssetType.HardCash:
                        sql = "SELECT ID,null AS StockExchangeID,ID AS CurrencyID,Description AS Name,"
                            + " CASE WHEN Sign IS NULL THEN IsoCode ELSE Sign + ' Cash' END AS Ticker"
                            + " FROM Currency WHERE ID IN ({0})";
                        break;
                    case AssetType.BenchmarkIndex:
                        sql = "SELECT ID,null AS StockExchangeID,CurrencyID,Description,Ticker"
                            + "FROM StockIndex WHERE ID IN ({0})";
                        break;
                    case AssetType.Stock:
                        sql = "SELECT ID,StockExchangeID,CurrencyID FROM Stock WHERE ID IN ({0})";
                        if (needNameTicker)
                        {
                            qXchg = sql;
                            // HACK: the following produces non-historical Stock.Name. If fixed, remove the another HACK (see above)
                            sql = "SELECT tmp.Idx,s.CurrencyID,s.Name,dbo.GetHistoricalStockTicker(s.ID,tmp.Date) as Ticker"
                                  + FROM_splitStringToTable + "JOIN Stock s ON (s.ID=tmp.ID)";
                        }
                        break;
                    case AssetType.Option:
                        sql = "SELECT ID, StockExchangeID, CurrencyID"
                            + " FROM [Option] o WHERE ID IN ({0})"; // (508109,508099,508011,507983) or (892164,885121,885920)
                        if (needNameTicker)
                        {
                            qXchg = sql;
                            sql = Utils.FormatInvCult("SELECT t.*,c.Sign FROM ("
                                + " SELECT tmp.Idx, o.CurrencyID, CASE o.UnderlyingAssetType"
                                + " WHEN {0} THEN (SELECT IsoCode FROM Currency c WHERE c.ID = UnderlyingSubTableID)"
                                + " WHEN {1} THEN dbo.GetHistoricalStockTicker(UnderlyingSubTableID,tmp.Date)"
                                + " WHEN {2} THEN (SELECT Ticker FROM Futures WHERE Futures.ID = o.UnderlyingSubTableID)"
                                + " WHEN {3} THEN (SELECT Ticker FROM StockIndex si WHERE si.ID = UnderlyingSubTableID)"
                                + " END AS underlyingTickerHistorical"
                                + ", o.Flags, o.ExpirationDate, o.StrikePrice",
                                (int)AssetType.HardCash, (int)AssetType.Stock, (int)AssetType.Futures, (int)AssetType.BenchmarkIndex)
                                + FROM_splitStringToTable + "JOIN [Option] o ON (o.ID=tmp.ID)" +
                                ") t LEFT JOIN Currency c ON (c.ID=t.CurrencyID)";
                            // DataRow: 0:Idx,1:CurrencyID,2:underlyingTickerHistorical,3:Flags,4:Exp.Date,5:StrikePrice,6:cSign
                            nameTickerCalculator = (p_row) => {
                                string _ticker = Utils.DBNullCast<string>(p_row[2]), _name;
                                ComposeOptionNameAndTicker(out _name, ref _ticker,
                                    Utils.DBNullableCast<OptionFlags>(p_row[3]).Value,
                                    Convert.ToDateTime(p_row[4]), Convert.ToDouble(p_row[5]),
                                    Utils.DBNullCast<string>(p_row[6]));
                                return new KeyValuePair<string,string>(_name, _ticker);
                            };
                        }
                        break;
                    case AssetType.Futures:
                        sql = "SELECT ID,StockExchangeID,CurrencyID FROM Futures WHERE ID IN ({0})";
                        if (needNameTicker)
                        {
                            qXchg = sql;
                            sql = Utils.FormatInvCult("SELECT tmp.Idx,f.CurrencyID,f.ExpirationDate,f.Ticker,"  // 0-3
                                + " (SELECT Sign FROM Currency WHERE Currency.ID=f.CurrencyID),"                // 4
                                + " UnderlyingAssetType,UnderlyingSubTableID,CASE UnderlyingAssetType"          // 5-7
                                + " WHEN {0} THEN (SELECT IsoCode FROM Currency c WHERE c.ID=UnderlyingSubTableID)"
                                + " WHEN {1} THEN dbo.GetHistoricalStockTicker(UnderlyingSubTableID,ExpirationDate)"
                                + " WHEN {2} THEN (SELECT Ticker FROM StockIndex si WHERE si.ID=UnderlyingSubTableID)"
                                // TODO: support for other underlyings
                                + " ELSE NULL END",
                                (int)AssetType.HardCash, (int)AssetType.Stock, (int)AssetType.BenchmarkIndex)
                                + FROM_splitStringToTable + "JOIN Futures f ON (f.ID=tmp.ID)";
                            // DataRow: 0:Idx,1:CurrencyID,2:Exp.Date,3:Ticker,4:cSign,5:uAt,6:uId,7:HistoricalTickerOfUnderlying
                            nameTickerCalculator = (p_row) => {
                                string _ticker = Utils.DBNullCast<string>(p_row[3]).TrimOrNull();
                                string uticker = Utils.DBNullCast<string>(p_row[7]).TrimOrNull();
                                if (String.IsNullOrEmpty(_ticker) || String.IsNullOrEmpty(uticker))
                                {
                                    int idx = Convert.ToInt32(p_row[0]);
                                    var f = new MemTables.Futures() {
                                        ID = result.m_assets[idx].First.ID,
                                        Ticker = _ticker,
                                        StockExchangeID = Utils.DBNullableCast<StockExchangeID>(p_row[1]).Value,
                                        ExpirationDate = Convert.ToDateTime(p_row[2]),
                                        UnderlyingAssetType = Utils.DBNullableCast<AssetType>(p_row[5]).Value,
                                        UnderlyingSubTableID = Convert.ToInt32(p_row[6])
                                    };
                                    _ticker = ComposeFuturesTicker(f, uticker, tickerProvider);
                                    if (String.IsNullOrEmpty(uticker))
                                        uticker = DBUtils.GetTicker(tickerProvider, f.UnderlyingAssetType, f.UnderlyingSubTableID,
                                            f.ExpirationDate - 1, false);
                                }
                                return new KeyValuePair<string,string>(
                                    ComposeFuturesName(uticker, Convert.ToDateTime(p_row[2]), Utils.DBNullCast<string>(p_row[4])),
                                    _ticker);
                            };
                        }
                        break;
                    default:
                        // TODO: support for other asset types
                        Utils.DebugAssert(false, at);
                        continue;
                }
                Dictionary<int, StockExchangeID> subtableId2Xchg = null;
                ILookup<int, int> subtableId2Idx = result.GetSubTableID2PositionsMap(at);
                string ids = JoinIdsOrNull(subtableId2Idx.Select(grp => grp.Key));
                if (qXchg == null)
                    sql = String.Format(sql, ids);
                else
                {
                    // Query StockExchangeID about every asset.
                    // Use this to convert every PortfolioItem.TimeUtc from UTC to local.
                    // Then inject the {asset, local time} info into 'sql' so that it can
                    // produce historical tickers.
                    // Example: '11/29/2011 1 508109,11/29/2011 2 508099,11/29/2011 3 507983'

                    qXchg = String.Format(qXchg, ids);
                    subtableId2Xchg = new Dictionary<int, StockExchangeID>();
                    foreach (DataRow row in dbManager.ExecuteQuery(qXchg, g_readingTimeoutSec).Rows)
                    {
                        if (!row.IsNull(1))
                            subtableId2Xchg[Convert.ToInt32(row[0])] = (StockExchangeID)Convert.ToInt32(row[1]);
                    }
                    qXchg  = null;
                    var lb = new ListBuilder(",");
                    var invCult = System.Globalization.CultureInfo.InvariantCulture;
                    string idxLen = result.GetPositions(at).Max().ToString(invCult).Length.ToString(invCult);
                    string fmt = "{0} {1," + idxLen + "} {2}";
                    foreach (int idx in result.GetPositions(at))
                    {
                        IAssetID asset = result.m_assets[idx].First;
                        DateTime t = result.m_assets[idx].Third.TimeUtc;
                        StockExchangeID xchg;
                        if (!subtableId2Xchg.TryGetValue(asset.ID, out xchg))
                            xchg = StockExchangeID.Unknown;
                        lb.AddFormat(invCult, fmt, DBUtils.Date2Str(t.ToLocal(xchg, dbManager)), idx, asset.ID);
                    }
                    sql = String.Format(sql, lb.ToString(), DateStrLength, idxLen);
                }
                foreach (DataRow row in dbManager.ExecuteQuery(sql, g_readingTimeoutSec).Rows)
                {
                    int col = -1, id = Convert.ToInt32(row[++col]);
                    StockExchangeID xchg;
                    if (subtableId2Xchg == null)
                        xchg = Utils.DBNullCast(row[++col], StockExchangeID.Unknown);
                    else if (!subtableId2Xchg.TryGetValue(result.m_assets[id].First.ID, out xchg))
                        xchg = StockExchangeID.Unknown;
                    CurrencyID c = Utils.DBNullCast(row[++col], CurrencyID.Unknown);
                    if (needNameTicker)
                    {
                        if (nameTickerCalculator == null)
                        {
                            name   = Utils.DBNullCast<string>(row[++col]).Interned();
                            ticker = Utils.DBNullCast<string>(row[++col]).Interned();
                        }
                        else
                        {
                            var pair = nameTickerCalculator(row);
                            name = pair.Key.Interned(); ticker = pair.Value.Interned();
                        }
                    }
                    foreach (int i in (subtableId2Xchg != null ? Utils.Single(id) : subtableId2Idx[id]))
                        result.m_assets[i].Third = p_itemLoader(result.m_assets[i].Third, c, xchg, name, ticker);
                }
            }
            return new LoadPortfolioItemsResult { m_result = result };
        }
        class LoadPortfolioItemsResult : AbstractList<PortfolioItemPlus>
        {
            internal HQCommon.Screener.AssetTypeChains<PortfolioItemPlus> m_result;
            public override int Count { get { return m_result.Count; } }
            public override PortfolioItemPlus this[int index]
            {
                get { return m_result.m_assets[index].Third; }
                set { throw new InvalidOperationException(); }
            }
        }


        public static PortfolioItemPlus DefaultItemLoader(PortfolioItemPlus p_pip, CurrencyID p_currency,
            StockExchangeID p_stockExchangeId, string p_name, string p_ticker)
        {
            return new PortfolioItemPlus(p_pip.ToPortfolioItem(), p_currency, p_stockExchangeId);
        }

        static void ComposeOptionNameAndTicker(out string p_name, ref string p_ticker,
            OptionFlags p_flags, DateTime p_expirationDate, double p_strikePrice,
            string p_currencySign)
        {
            // Name:"Call:@SPY Ex:12-01 Str:$130",  Ticker: "@SPY 120121C00130000"
            string call = (p_flags & OptionFlags.IsCall) != 0 ? "Call" : "Put";
            if (String.IsNullOrEmpty(p_currencySign))
                p_currencySign = "\u00A4";
            p_name = Utils.FormatInvCult("{0}:@{1} Ex:{2:yy'-'MM} Str:{4}{3:g5}", call, p_ticker.TrimOrNull(),
                p_expirationDate, p_strikePrice, p_currencySign);
            string s = p_strikePrice.ToString("f3", Utils.InvCult);
            s = s.Remove(s.Length - 4, 1);  // remove '.'
            s = s.Length < 8 ? s.Insert(0, new String('0', 8 - s.Length)) : s;
            p_ticker = Utils.FormatInvCult("@{0} {1:yyMMdd}{2}" + s, p_ticker.TrimOrNull(),
                p_expirationDate, call[0]);
        }

        static string ComposeFuturesName(string p_tickerOfUnderlying, DateTime p_expirationDate,
            string p_currencySign)
        {
            // Name:"Fut:#VIX 11-04" or "Fut:#VIX 11-04 ¤". (# instead of @ according to email 0x4f4e6a02)
            p_tickerOfUnderlying = "Fut:#" + p_tickerOfUnderlying.TrimOrNull();
            if (p_currencySign == "$")
                return p_tickerOfUnderlying + p_expirationDate.ToString("' 'yy'-'MM", Utils.InvCult);
            return Utils.FormatInvCult("{0} {2:yy'-'MM} {3}", p_tickerOfUnderlying,
                p_expirationDate, p_currencySign ?? "\u00a4");
        }

        /// <summary> If p_futures.Ticker is missing, returns "#"+p_tickerOfUnderlying+YYYYMMDD
        /// of ExpirationDate.
        /// If p_tickerOfUnderlying is missing, too, tries to generate the historical ticker
        /// of the underlying at p_futures.ExpirationDate - 1days. For this, uses p_tp and
        /// p_futures.{Underlying*,ExpirationDate,ID} (in this case only). The last resort
        /// is something like "Futures(103)". </summary>
        public static string ComposeFuturesTicker(MemTables.Futures p_futures, string p_tickerOfUnderlying,
            ITickerProvider p_tp)
        {
            if (!String.IsNullOrEmpty(p_futures.Ticker))
                return p_futures.Ticker;
            if (String.IsNullOrEmpty(p_tickerOfUnderlying) && p_tp != null
                && p_futures.UnderlyingAssetType != AssetType.Unknown)
            {
                p_tickerOfUnderlying = p_tp.GetTicker(p_futures.UnderlyingAssetType,
                    p_futures.UnderlyingSubTableID, p_futures.ExpirationDate - 1);
            }
            if (String.IsNullOrEmpty(p_tickerOfUnderlying))
                return DefaultAssetIDString(AssetType.Futures, p_futures.ID);
            // '#' according to email#4f4e6a02, YYYYMMDD according to SkypeGyuri2014.txt Mar-18 12:17
            return "#" + p_tickerOfUnderlying + p_futures.ExpirationDate.Date.ToString("yyyyMMdd");
        }

        static string ComposeCurrencyNameAndTicker(MemTables.Currency p_cRow, out string p_ticker)
        {
            if (!String.IsNullOrEmpty(p_cRow.Sign))
                p_ticker = (p_cRow.Sign + " Cash").Interned();
            else if (!String.IsNullOrEmpty(p_cRow.IsoCode))
                p_ticker = p_cRow.IsoCode;
            else
                p_ticker = null;
            return (p_cRow.Description == null) ? null : p_cRow.Description;    // Name
        }

        /// <summary> Precondition: p_ctx.DBManager != null && p_ctx.OptionProvider != null.
        /// If p_ctx.TickerProvider == null and p_needNameTicker==true, the Stock.Ticker will
        /// be used (or DefaultAssetIDString()) </summary>
        internal static void GetOptionAdditionalFieldsFromMemTables(int p_optionId,
            DateTime p_timeUtc, IContext p_ctx, bool p_needNameTicker, out StockExchangeID p_xchg,
            out CurrencyID p_currency, out string p_name, out string p_ticker)
        {
            DBManager dbManager = DBManager.FromObject(p_ctx, true);
            MemTables.Option? option = p_ctx.OptionProvider.GetOptionById(p_optionId);
            p_xchg = StockExchangeID.Unknown;
            p_currency = CurrencyID.Unknown;
            p_name = p_ticker = null;
            if (!option.HasValue)
                return;
            p_xchg = option.Value.StockExchangeID;
            p_currency = option.Value.CurrencyID;
            HQCommon.MemTables.Currency cRow;
            AssetType uat = option.Value.UnderlyingAssetType;
            int u = option.Value.UnderlyingSubTableID;
            if (!p_needNameTicker)
                return;
            if (uat != AssetType.Option && p_ctx.TickerProvider != null)
                p_ticker = p_ctx.TickerProvider.GetTicker(uat, u, p_timeUtc, p_nullIfUnknown: false);
            else switch (uat)
            {
                case AssetType.HardCash:
                    p_ticker = (dbManager.MemTables.Currency.TryGetValue((int)p_currency, out cRow)) ? 
                        cRow.IsoCode : new Cash(p_currency).ISOcode;
                    break;
                case AssetType.Stock:
                {
                    MemTables.Stock stockRow;
                    if (dbManager.MemTables.Stock.TryGetValue(u, out stockRow))
                        p_ticker = stockRow.Ticker;
                    break;
                }
                case AssetType.Futures:
                {
                    MemTables.Futures? f;
                    if (p_ctx.FuturesProvider != null 
                        && (f = p_ctx.FuturesProvider.GetFuturesById(option.Value.UnderlyingSubTableID)).HasValue)
                        p_ticker = ComposeFuturesTicker(f.Value, null, p_ctx.TickerProvider);
                    break;
                }
                case AssetType.BenchmarkIndex:
                    StockIndex.Init(p_ctx, false);
                    var si = new StockIndex(u);
                    p_ticker = si.m_ticker ?? si.ToString();
                    break;
                // TODO: support for other asset types
            }
            string cSign = dbManager.MemTables.Currency.TryGetValue((int)p_currency, out cRow) ? cRow.Sign
                : GetCurrencySign(AssetType.HardCash, (int)p_currency, dbManager, p_ctx.TickerProvider);
            ComposeOptionNameAndTicker(out p_name, ref p_ticker, option.Value.Flags,
                option.Value.ExpirationDate, option.Value.StrikePrice, cSign);
        }

        #endregion

        public static string GetDefaultConnectionString(DBType p_dbType)
        {
            switch (p_dbType)
            {
                case DBType.Remote:
                    return DBManager.EmbedAppnameInConnString(HQCommon.Properties.Settings.Default.ServerHedgeQuantConnectionString);
                case DBType.Local :
                    return HQCommon.Properties.Settings.Default.ClientHedgeQuantConnectionString;
                default:
                    throw new NotImplementedException();
            }
        }

        public static int RequiredSdfVersion
        {
            get { return DBUtils.MemTablesVersion; }
        }

        /// <summary> Something like "2,13,103" or "null" when p_ids is empty. 
        /// Designed for sql constructs like this: WHERE col IN (...)
        /// </summary>
        public static string JoinIdsOrNull(IEnumerable<int> p_ids)
        {
            string result = Utils.Join(",", p_ids, System.Globalization.CultureInfo.InvariantCulture);
            return String.IsNullOrEmpty(result) ? "null" : result;
        }

        /// <summary> Returns p_stock.CompanyID, or -1 if p_stock.IsCompanyIDNull() is true </summary>
        public static int GetNonNullCompanyID(this HQCommon.MemTables.Stock p_stock)
        {
            return p_stock.CompanyID == null ? -1 : (int)p_stock.CompanyID;
        }

        public static IList<T> SelectListDb<T>(this DataRowCollection p_rows, Func<DataRow, T> p_selector)
        {
            if (p_rows == null)
                return (IList<T>)Enumerable.Empty<T>();
            if (p_selector == null)
                throw new ArgumentNullException();
            return new SelectListHelper<T> { m_rows = p_rows, m_selector = p_selector };
        }
        class SelectListHelper<T> : AbstractList<T>
        {
            internal Func<DataRow, T> m_selector;
            internal DataRowCollection m_rows;
            public override int Count { get { return m_rows.Count; } }
            public override T this[int index]
            {
                get { return m_selector(m_rows[index]); }
                set { throw new NotSupportedException(); }
            }
            public override IEnumerator<T> GetEnumerator()
            {
                foreach (DataRow row in m_rows)
                    yield return m_selector(row);
            }
        }

        /// <summary> A replacement for DBManager.ExecuteQuery(...).Rows, which causes
        /// NullReferenceException when DBManager.IsEnabled=false (because ExecuteQuery()==null).
        /// This function returns an empty DataRowCollection in that case. 
        /// Note: ExecuteQuery()==null allows detecting that the query did not run at all.
        /// </summary>
        public static DataRowCollection RowsOrEmpty(this DataTable p_table)
        {
            DataRowCollection result = (p_table == null) ? null : p_table.Rows;
            return result ?? (new DataTable().Rows);
        }

        #region Debugging tools

        /// <summary> Extracts the value of the property/field named "AssetID"
        /// from the elements of p_seq and returns its ticker at p_tickerTimeUtc
        /// (if null, now) in the Key fields of the returned sequence.
        /// Designed for debugging to be used in the QuickWatch window.
        /// Example:  GetTickers(p_seq,null).OrderByKeys()
        /// </summary>
        public static IEnumerable<KeyValuePair<string, object>>
            GetTickers(System.Collections.IEnumerable p_seq, ITickerProvider p_tp, DateTime? p_tickerTimeUtc = null)
        {
            if (p_seq != null)
                foreach (object item in p_seq)
                {
                    IAssetID assetID = GetAssetID(item);
                    yield return new KeyValuePair<string, object>(
                        assetID == null ? null : assetID.ToString(p_tp, p_tickerTimeUtc), item);
                }
        }

        /// <summary> Extracts the value of the property/field named "AssetID"
        /// from p_obj using reflection. Designed for debugging. </summary>
        public static IAssetID GetAssetID(object p_obj)
        {
            IAssetID result = p_obj as IAssetID;
            if (result == null && p_obj != null)
                Utils.GetValueOfMember("AssetID", p_obj, out result);
            return result;
        }

        /// <summary> p_maxLen==0 means the value of MaxLenOfLoggedSqlCmd from .exe.config, 2560 by default. -1 means unlimited. </summary>
        public static string LimitedLengthSqlString(object p_sql, int p_maxLen = 0, string p_abbrevIfAlreadyLogged = null)
        {
            if (p_maxLen == 0)
                p_maxLen = g_MaxLenOfLoggedSqlCmd.AutoCreate("MaxLenOfLoggedSqlCmd", p_parserFuncWDef: (str, _, p_this) => {
                    int i = new Parseable(str, p_this.SettingName, p_this.SettingsFunc()).Default(2560);
                    return (i == 0) ? -1 : i;
                }).Value;
            string sql = Utils.ToStringOrNull(p_sql);
            if (p_abbrevIfAlreadyLogged != null && (192 < sql.Length || 4 <= sql.Split('\n').Length)
                && Utils.MarkMsgLogged(ref sql, p_abbrevIfAlreadyLogged))
                return sql;
            if (sql == null || sql.Length <= p_maxLen)
                return sql;
            // See how many of the text is in parentheses
            var matches = Regex.Matches(sql, @"\([^(]+\)");
            //const string Mark = "(\u22ef)"; const int nM = 3;
            const string Mark = Utils.RemovedTextMark; const int nM = Utils.RemovedTextMarkLen;
            int inParentheses = matches.Cast<Match>().Sum(m => m.Length);
            int all_p_removed = sql.Length - inParentheses, n = matches.Count;
            if (p_maxLen <= all_p_removed + n * nM)
            {   // Will be too long after removing all parenthesized regions: don't bother with them
                return Utils.RemoveMiddleIfLong(sql, p_maxLen);     // p_maxLen < 0 means unlimited!
            }
            // Cut from the longest parenthesized regions first, or in case of equal lengths,
            // from the later ones. The above 'if' guarantees that we will succeed before
            // removing all the parenthesized text.
            Match[] sortedMatches = (from m in matches.Cast<Match>()
                                     orderby m.Length descending, m.Index descending
                                     select m).ToArray();
            // If completely removing the two longest parentheses is not enough,
            // then double the limit. If that's enough, then accept that
            // (Reasoning: it's likely a complex SQL without many data. Avoid
            //  hiding characters in its smaller but equally important parts)
            if (p_maxLen <= sortedMatches.Take(2).Sum(m => m.Length) + Math.Min(2, n) * nM
                && sql.Length <= (p_maxLen *= 2))       // increase p_maxLen.
                return sql;
            int leaveInP = p_maxLen - all_p_removed, idx = Math.Min(3, n) >> 1;
            var toRemove = new List<KeyValuePair<int, int>>();
            foreach (Match match in sortedMatches)
            {
                int begin = match.Index, count = match.Length;
                // After completely removing this item (more exactly: reducing it to the obligatory nM chars)
                // all the remaining items may fit without removing anything of them, PLUS j extra chars
                // -> these j chars of this item should be preserved. But don't keep 1 or 2 chars; min. nM
                int j = leaveInP - (inParentheses - count + nM);
                // If all the remaining items won't fit (they have to be reduced, too: j < 2), then distribute
                // the available characters among the remaining items of the second half.
                j = (1 < j) ? j : (leaveInP / n - nM) & (--idx >> 31);
                if (1 < j)
                {
                    begin += j - (j / 2);
                    count -= j;
                    leaveInP -= j;
                }
                --n; leaveInP -= nM;
                toRemove.Add(new KeyValuePair<int, int>(begin, count));
                inParentheses -= match.Length;
                if (inParentheses <= leaveInP)
                    break;
            }
            toRemove.Sort((kv1, kv2) => kv1.Key.CompareTo(kv2.Key));
            var result = new System.Text.StringBuilder();
            idx = 0;
            foreach (var beginAndCount in toRemove)
            {
                result.Append(sql, idx, beginAndCount.Key - idx);
                result.Append(Mark);  // nM characters -- this is the reason of those nM's above
                idx = beginAndCount.Key + beginAndCount.Value;
            }
            result.Append(sql, idx, sql.Length - idx);
            return result.ToString();
        }
        static StringableSettingStruct<int> g_MaxLenOfLoggedSqlCmd;

        #endregion

        // Helper method used to fill in the PortfolioItemPlus.CurrencyID field 
        /// <summary> p_dbManager is any object supported by DBManager.FromObject().
        /// May be null when p_assetType==HardCash and after the first
        /// time when p_assetType!=Stock and !=HardCash. </summary>
        public static CurrencyID GetCurrencyID(AssetType p_assetType, int p_subTableID,
            object p_dbManager)
        {
            if (p_assetType == AssetType.HardCash)
                return (CurrencyID)p_subTableID;
            if (g_nonUsdAssets == null)
            {
                DBManager dbManager = DBManager.FromObject(p_dbManager, p_throwOnNull: true);
                MemoryTables m = dbManager.MemTables;
                var stockTable = (m == null) ? m.Stock : null;  //  always null, intentionally (capturing type only)
                if (p_assetType == AssetType.Stock && m.IsLoaded(stockTable))
                {
                    HQCommon.MemTables.Stock row;
                    if (m.Stock.TryGetValue(p_subTableID, out row) && row.CurrencyID.HasValue)
                        return (CurrencyID)row.CurrencyID;
                    return CurrencyID.Unknown;
                }
                var nonUsdAssets = new Dictionary<int, CurrencyID>();
                if (m.IsLoaded(stockTable))
                    foreach (HQCommon.MemTables.Stock row in m.Stock.Values.Where(stock =>
                        stock.CurrencyID == null || stock.CurrencyID != CurrencyID.USD))
                    {
                        nonUsdAssets[AssetIdInt32Bits.IntValue(AssetType.Stock, row.ID)] = row.CurrencyID ?? CurrencyID.Unknown;
                    }
                else
                    foreach (DataRow row in dbManager.ExecuteQuery(Utils.FormatInvCult(
                        "SELECT ID,CurrencyID FROM Stock WHERE (CurrencyID IS NULL) OR (CurrencyID != {0})",
                        (int)CurrencyID.USD), g_readingTimeoutSec).Rows)
                    {
                        nonUsdAssets[AssetIdInt32Bits.IntValue(AssetType.Stock, Convert.ToInt32(row[0]))] =
                            row.IsNull(1) ? CurrencyID.Unknown : (CurrencyID)Convert.ToInt32(row[1]);
                    }

                // TODO: support for other asset types
                foreach (var x in new[] { 
                    new { type = AssetType.BenchmarkIndex, sql = Utils.FormatInvCult(
                        "SELECT ID,CurrencyID FROM StockIndex WHERE (CurrencyID IS NULL) OR (CurrencyID != {0})",
                        (int)CurrencyID.USD) },
                    new { type = AssetType.Option, sql = Utils.FormatInvCult(
                        "SELECT ID,CurrencyID FROM [Option] WHERE (CurrencyID IS NULL) OR (CurrencyID != {0})",
                        (int)CurrencyID.USD) },
                    new { type = AssetType.Futures, sql = Utils.FormatInvCult(
                        "SELECT ID,CurrencyID FROM Futures WHERE (CurrencyID IS NULL) OR (CurrencyID != {0})",
                        (int)CurrencyID.USD) }
                })
                {
                    try
                    {
                        foreach (DataRow row in dbManager.ExecuteQuery(x.sql, g_readingTimeoutSec).Rows)
                            nonUsdAssets[AssetIdInt32Bits.IntValue(x.type, Convert.ToInt32(row[0]))] =
                                row.IsNull(1) ? CurrencyID.Unknown : (CurrencyID)Convert.ToInt32(row[1]);
                    }
                    catch (Exception e)
                    {
                        Trace.WriteLine(Logger.FormatExceptionMessage(e, false, "occurred in {0}"
                            + "\nNon-USD {1}s will be treated as if they were in USD",
                            Utils.GetCurrentMethodName(), x.type));
                    }
                }
                Thread.MemoryBarrier();
                g_nonUsdAssets = nonUsdAssets;

                g_GetCurrencyID_chgntf.AddHandler(dbManager, (dbM,_) => {
                    g_nonUsdAssets = null;
                    GetCurrencyID(AssetType.BenchmarkIndex, 1, dbM);
                }).SetDependencies(ChangeNotification.Flags.AllTableEvents,
                    typeof(MemTables.Stock), typeof(MemTables.StockIndex),
                    typeof(MemTables.Option), typeof(MemTables.Futures));
            }
            else
            {
                g_GetCurrencyID_chgntf.UpdateNowIfMissed(p_dbManager);
            }
            CurrencyID cid;
            if (!g_nonUsdAssets.TryGetValue(AssetIdInt32Bits.IntValue(p_assetType, p_subTableID), out cid))
                cid = CurrencyID.USD;
            return cid;
        }
        private static Dictionary<int, CurrencyID> g_nonUsdAssets;
        private static StaticChangeHandlerWithWeakRef<DBManager> g_GetCurrencyID_chgntf;

        public static CurrencyID TryGetCurrencyID(AssetType p_assetType, int p_subTableID,
            object p_dbManager = null)
        {
            return (p_assetType != AssetType.HardCash && p_dbManager == null && g_nonUsdAssets == null) ? CurrencyID.Unknown
                : GetCurrencyID(p_assetType, p_subTableID, p_dbManager);
        }

        public static string GetCurrencySign(AssetType p_assetType, int p_subTableID,
            object p_dbManager, ITickerProvider p_tp)
        {
            int c = (p_assetType == AssetType.HardCash) ? p_subTableID : (int)DBUtils.TryGetCurrencyID(p_assetType, p_subTableID, p_dbManager);
            string cSign = null;
            if (c != (int)CurrencyID.Unknown)
            {
                IContext ctx;
                if (p_tp == null && Utils.CanBe(p_dbManager, out ctx))
                    p_tp = ctx.TickerProvider;
                cSign = GetTicker(p_tp, AssetType.HardCash, c, p_nullIfUnknown: true);
            }
            return String.IsNullOrEmpty(cSign) ? "\u00a4" : cSign.Substring(0, 1);
        }

        #region UTF8 in VARCHAR
        /// <summary> Prepares a unicode string to be stored in a VARCHAR column 
        /// (not NVARCHAR). Encodes it with UTF8, then expresses the bytes in
        /// sql server's encoding </summary>
        public static string EncodeToVARCHAR(string p_string)
        {
            return IsFitInVARCHAR(p_string) ? p_string
                : SqlServerEncoding.GetString(Encoding.UTF8.GetBytes(p_string));
        }
        public static bool IsFitInVARCHAR(string p_string)
        {
            for (int i = (p_string == null) ? 0 : p_string.Length; --i >= 0; )
                if (128 <= p_string[i])
                {
                    // The following allows passing several symbols (like euro/font/yen etc.)
                    // without involving UTF-8
                    if (g_serverChars128_191 == null)
                        g_serverChars128_191 = SqlServerEncoding.GetString(
                            Enumerable.Range(128, 64).Select(j => (byte)j).ToArray());
                    if (g_serverChars128_191.IndexOf(p_string[i]) < 0)
                        return false;
                }
            return true;
        }

        // Sql server's encoding: SELECT SERVERPROPERTY('Collation') == 'SQL_Latin1_General_CP1_CI_AS'
        // where CP1 means CP1252 (see http://j.mp/ktxXDF)
        public static Encoding SqlServerEncoding
        {
            get { return s_serverEncoding ?? (s_serverEncoding = (Encoding)Encoding.GetEncoding(1252).Clone()); }
        }
        [ThreadStatic]
        static Encoding s_serverEncoding;
        private static string g_serverChars128_191;

        /// <summary> Restores the encoding of a string that was encoded
        /// with EncodeToVARCHAR(). </summary>
        public static string DecodeFromVARCHAR(string p_string)
        {
            for (int i = (p_string ?? String.Empty).Length - 1; i >= 0; --i)
                if (192 <= p_string[i])
                    return Encoding.UTF8.GetString(SqlServerEncoding.GetBytes(p_string));
            return p_string;
        }
        #endregion

        public static System.Data.Common.DbParameter[] MakeVarChar(string p_name, string p_value, bool p_isNVarChar = true, ushort p_fixedSize = 8001)
        {
            var p = new SqlParameter(p_name, p_isNVarChar ? SqlDbType.NVarChar : SqlDbType.VarChar,
                p_fixedSize <= 8000 ? p_fixedSize : -1);
            p.Value = p_value;
            return new System.Data.Common.DbParameter[] { p };
        }
    }

    public class ConnectionException : Exception
    {
        public DBManager DBManager { get; private set; }
        public ConnectionException() { }
        public ConnectionException(string p_message) : base(p_message) { }
        public ConnectionException(string p_message, Exception p_innerException) : base(p_message, p_innerException) { }
        public ConnectionException(string p_message, Exception p_innerException, DBManager p_source)
            : base(p_message, p_innerException) { this.DBManager = p_source; }
    }

    /// <summary> Assists static ChangeNotification handlers by maintaining a *weak*
    /// reference to a T (usually DBManager): when the weak reference is null, omits
    /// calling the ChangeNotification handler, but when a strong reference is provided
    /// again, the missed call is supplied.
    /// This helps to avoid spawning unnecessary strong references to instances of T. </summary>
    struct StaticChangeHandlerWithWeakRef<T> where T : class
    {
        /// <summary> m_rec.m_second is true if cache re-loading failed because m_rec.m_first.Target
        /// was null. The cache should be re-loaded as soon as a valid T instance is seen. </summary>
        Rec<WeakReference, bool> m_rec;
        ChangeNotification.Filter m_handler;
        /// <summary> If the invocation of the ChangeNotification handler (= updating of the cache)
        /// was missed recently (because the stored weak reference was null) and p_strongRef!=null,
        /// executes the handler now; otherwise does nothing. Returns true always. </summary>
        public bool UpdateNowIfMissed(object p_strongRef)
        {
            if (m_rec != null && m_rec.m_second && p_strongRef != null)
            {
                object strongRef = p_strongRef as T;
                if (strongRef == null && typeof(T) == typeof(DBManager))
                    strongRef = DBManager.FromObject(strongRef, p_throwOnNull: false);
                if (strongRef != null)
                {
                    m_rec.m_first = new WeakReference(strongRef);
                    if (m_handler != null)      // must be true, but... just to be sure
                        m_handler.Invoke();
                }
            }
            return true;
        }
        public ChangeNotification.Filter AddHandler(object p_strongRef, Action<T, ChangeNotification.Args> p_handler)
        {
            if (typeof(T) == typeof(DBManager))
                p_strongRef = DBManager.FromObject(p_strongRef, p_throwOnNull: false);
            var rec = new Rec<WeakReference, bool>(new WeakReference(p_strongRef), false);
            ChangeNotification.Filter result = ChangeNotification.AddHandler(ref m_handler, p_notification => {
                T strongRef = rec.m_first.Target as T;
                // p_notification.Arguments is checked because: consider the following scenario.
                // You register m_handler for notifications about table X, with T=DBManager instance#1.
                // Later instance#1 is disposed and instance#2 announces DBManager.IsEnable=true
                // (OfflineToOnlineTransition). This triggers m_handler. Without p_notification.Arguments
                // it wouldn't call p_handler() until UpdateNowIfMissed(). In other words, the only
                // benefit of ChangeNotification would be to let UpdateNowIfMissed() know when to
                // call p_handler() and when not. With p_notification.Arguments, p_handler() gets called in advance.
                if (strongRef == null && p_notification != null && (strongRef = p_notification.Arguments as T) != null)
                    rec.m_first = new WeakReference(strongRef);
                if (!(rec.m_second = (strongRef == null)))
                    p_handler(strongRef, p_notification);
            }, Utils.GetQualifiedMethodNameLazy(p_handler));
            Thread.MemoryBarrier();             // defense against concurrent UpdateNowIfMissed()
            m_rec = rec;
            return result;
        }
    }
}
